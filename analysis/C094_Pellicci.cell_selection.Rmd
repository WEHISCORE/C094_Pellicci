---
title: "Selection of biologically relevant cells for Pellicci gamma-delta T-cell data set"
description: |
author:
  - name: William Ho 
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/rory-bowden/4536/wehi-advanced-genomics-facility
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)
library(pheatmap)
source(here("code", "helper_functions.R"))
# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))
knitr::opts_chunk$set(fig.path = "C094_Pellicci.cell_selection_files/")
```

# Motivation

scRNA-seq datasets may include cells that are not relevant to the study, even after the initial quality control, which we don't want to include in downstream analyses.
In this section aim to filter out these 'unwanted' cells and retain only the 'biologically relevant' cells.
Examples of unwanted cells include:

- Cells with 'reasonable' QC metrics, but that are transcriptomically distinct from the majority of cells in the dataset
- Cells of unwanted cell types, such as those that might sneak through a FACS or magnetic bead enrichment sample preparation

Once we are confident that we have selected the biologically relevant cells, we will perform data integration (if necessary) and a further round of clustering in preparation for downstream analysis.

The removal of unwanted cells is an iterative process where at each step we:

1. Identify cluster(s) enriched for unwanted cells. The exact criteria used to define 'unwanted' will depend on the type of cells we are trying to identify at each step.
    a. Perform diagnostic checks to ensure we aren't discarding biologically relevant cells.
    b. Remove the unwanted cells.
2. Re-process the remaining cells.
    a. Identify HVGs.
    b. Perform dimensionality reduction (PCA and UMAP).
    c. Cluster cells.
    
<aside>
Throughout, we will exclude mitochondrial genes, ribosomal protein genes, sex chromosome genes, and pseudogenes from the HVGs.
</aside>

Clustering is a critical component of this process, so we discuss it in further detail in the next subsection.

## Clustering

Clustering is an unsupervised learning procedure that is used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles.
Its primary purpose is to summarize the data in a digestible format for human interpretation. 
This allows us to describe population heterogeneity in terms of discrete labels that are easily understood, rather than attempting to comprehend the high-dimensional manifold on which the cells truly reside.
Clustering is thus a critical step for extracting biological insights from scRNA-seq data.

Clustering calculations are usually performed using the top PCs to take advantage of data compression and denoising^[But see the 'Data integration' section of this report for an exception to the rule.].

### Clusters vs. cell types

It is worth stressing the distinction between clusters and cell types.
The former is an empirical construct while the latter is a biological truth (albeit a vaguely defined one).
For this reason, questions like "what is the true number of clusters?" are usually meaningless.
We can define as many clusters as we like, with whatever algorithm we like - each clustering will represent its own partitioning of the high-dimensional expression space, and is as "real" as any other clustering.

A more relevant question is "how well do the clusters approximate the cell types?"
Unfortunately, this is difficult to answer given the context-dependent interpretation of biological truth.
Some analysts will be satisfied with resolution of the major cell types; other analysts may want resolution of subtypes; and others still may require resolution of different states (e.g., metabolic activity, stress) within those subtypes.
Two clusterings can also be highly inconsistent yet both valid, simply partitioning the cells based on different aspects of biology.
Indeed, asking for an unqualified "best" clustering is akin to asking for the best magnification on a microscope without any context.

It is helpful to realize that clustering, like a microscope, is simply a tool to explore the data.
We can zoom in and out by changing the resolution of the clustering parameters, and we can experiment with different clustering algorithms to obtain alternative perspectives of the data.
This iterative approach is entirely permissible for data exploration, which constitutes the majority of all scRNA-seq data analysis.

## Graph-based clustering

We build a shared nearest neighbour graph [@xu2015identification] and use the Louvain algorithm to identify clusters.
We would build the graph using the principal components.

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Preprocessing the Pellicci gamma-delta T-cell data set'](C094_Pellicci.preprocess.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C094_Pellicci.preprocessed.SCE.rds"))
# Some useful colours
sample_type_colours <- setNames(
  unique(sce$colours$sample_type_colours),
  unique(names(sce$colours$sample_type_colours)))
sample_name_colours <- setNames(
  unique(sce$colours$sample_name_colours),
  unique(names(sce$colours$sample_name_colours)))

# NOTE: need to update samplecolours stored in SCE after introducing "post_hoc_sample_gate"
sample_gate_colours <- setNames(
  palette.colors(nlevels(sce$post_hoc_sample_gate), "Tableau 10"),
  levels(sce$post_hoc_sample_gate))
sce$colours$sample_gate_colours <- sample_gate_colours[sce$post_hoc_sample_gate]

plate_number_colours <- setNames(
  unique(sce$colours$plate_number_colours),
  unique(names(sce$colours$plate_number_colours)))
tissue_colours <- setNames(
  unique(sce$colours$tissue_colours),
  unique(names(sce$colours$tissue_colours)))
donor_colours <- setNames(
  unique(sce$colours$donor_colours),
  unique(names(sce$colours$donor_colours)))

# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$gene_symbol)
ribo_set <- intersect(ribo_set, rownames(sce))
sex_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME %in% c("X", "Y"))]
pseudogene_set <- rownames(sce)[
  any(grepl("pseudogene", rowData(sce)$ENSEMBL.GENEBIOTYPE))]
```

## Initial clustering

```{r}
set.seed(4759)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$colours$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot).

```{r clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 1.25}
p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = cluster), size = 0.25) +
  scale_colour_manual(values = cluster_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample_type), size = 0.25) +
  scale_colour_manual(values = sample_type_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample_name), size = 0.25) +
  scale_colour_manual(values = sample_name_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = post_hoc_sample_gate), size = 0.25) +
  scale_colour_manual(values = sample_gate_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p5 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = plate_number), size = 0.25) +
  scale_colour_manual(values = plate_number_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p6 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = tissue), size = 0.25) +
  scale_colour_manual(values = tissue_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p7 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = donor), size = 0.25) +
  # NOTE: Lots of levels, so need smaller font size.
  scale_colour_manual(values = donor_colours) + 
  theme_cowplot(font_size = 6) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

(p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | plot_spacer())
```

```{r cluster-barplot, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample_type),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_type_colours) +
  # NOTE: Lots of levels, so need smaller font size.
  theme_cowplot(font_size = 6)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample_name),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_name_colours) +
  theme_cowplot(font_size = 8)

p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = post_hoc_sample_gate),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_gate_colours) +
  theme_cowplot(font_size = 8)

p4 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)

p5 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = tissue_colours) +
  theme_cowplot(font_size = 8)

p6 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = donor_colours) +
  # NOTE: Lots of levels, so need smaller font size.
  theme_cowplot(font_size = 6)

(p1 | p2) / (p3 | p4) / (p5 | p6) 
```

NOTE:
**TODO: double check these notes**

  For the unmerged data, 
    - cluster 2, 4, and 6 represent the 3 types/status of cells within P8 and can be found in all blood and thymus samples
    - most of the cells in P5, P6 and P7 form 1 single cluster, i.e. cluster 3, and they found mostly in thymus sample only
    - cluster 1 and 5 are the only standalone clusters separated from the major group (and they are the only two clusters, need to decided "to keep or not to keep" during cell selection)
    - cluster 1 is basically the control cell line, accompanied with a small amount of cells from thymus 2 and 3
    - cluster 5 are formed from cells mostly from blood 3 and thymus 3 only, implying it was originated from donor 3 only somehow
    - merging or not will be decided based on if the feature above can be preserved/ sharpened

<!-- NOTE: -->
<!-- **TODO: double check these notes** -->

<!--   For `sample_name`, -->
<!--     - cluster 5 with most cells from `Blood 3`, but no cells from `Blood 1` -->
<!--     - cluster 3 with most cells from `Thymus` -->
<!--     - almost all cells in cluster 1 were from `Cell line` -->

<!--   For `post_hoc_sample_gate`, -->
<!--     - cluster 3 with more cells from phase `P5`, `P6`, and `P7` -->
<!--     - cluster 1 with almost all cells from `P5`, but no cells from `P7` -->

<!--   For `plate_number`, -->
<!--     - cluster 2 with more cells from plate `LCE511` -->
<!--     - cluster 5 with more cells from plate `LCE509` -->
<!--     - cluster 6 with more `LCE514` -->

<!--   For `tissue`, -->
<!--     - cluster 5 with cells mostly from `Blood` -->
<!--     - cluster 3 with cells mostly from `Thymus`  -->
<!--     - cluster 1 are mostly SKW3 cell line, accompanied with some `Thymus 2` and `Thymus 3` cells -->

<!--   For `donor`, -->
<!--     - cluster 5 with almost all cells from `donor 3` -->

<!-- Is `cluster 5` a unique cell type, or contamination from `Blood 3` of `donor 3` only ? Remove or keep ??? -->

**TODO: need to check for plate-specific clusters, donor-/ sample_name-specific cluster**

# Data integration

## Motivation

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for common downstream analysis.
However, existing methods based on linear models [@ritchie2015limma;@leek2012sva] assume that the composition of cell populations are either known or the same across batches.
To overcome these limitations, bespoke methods have been developed for batch correction of single-cell data [@haghverdi2018batch;@butler2018integrating;@lin2019scmerge] that do not require a priori knowledge about the composition of the population.
This allows them to be used in workflows for exploratory analyses of scRNA-seq data where such knowledge is usually unavailable.

We will use the Mutual Nearest Neighbours (MNN) approach of @haghverdi2018batch, as implemented in the `r BiocStyle::Biocpkg("batchelor")` package, to perform data integration.
The MNN approach does not rely on pre-defined or equal population compositions across batches, only requiring that a subset of the population be shared between batches.

## Analysis








## MNN1: All cells (all cells guiding merge)

We treat each plate as a batch and also test to manually provide the merge order.

**TODO: check if need to treat BOTH plate_number and donor/sample_name as batch !?**

```{r}
sce0 <- sce
```

```{r}
sce0$batch <- sce0$plate_number

var_fit <- modelGeneVarWithSpikes(sce0, "ERCC", block = sce0$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))
```

```{r, results = "hide"}
library(batchelor)
set.seed(1819)

# auto merge
mnn_out_1 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = TRUE,
  subset.row = hvg)

# manual merge 1
# NOTE: order defined based on the similarities in cell number between plates for each`sample_name`
mnn_out_2 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509"),
  subset.row = hvg)

# manual merge 2
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_3 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  subset.row = hvg)
```

One useful diagnostic of the MNN algorithm is the proportion of variance within each batch that is lost during MNN correction^[Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step.].
Large proportions of lost variance ($>10 \%$) suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].

<!-- In this case, the proportion of lost variance is small for most plates, indicating that non-orthogonality is not a major concern, except for the final merges incorporating plates `LC370` and `LC377`. -->
<!-- Loss of some proportion of variance within each batch seems inevitable for these two plates as the experimental groups on these plates are not shared with other plates: -->

<!-- - `LC370` contains the unique `PP.naive.tom+` and `PP.salmon.tom+` groups. -->
<!-- - `LC377` is the most diverse plate in terms of experimental groups and is the only plate containing cells from the `LI.citro.tom-` and `SI.citro.tom-` groups. -->

```{r}
tab1 <- metadata(mnn_out_1)$merge.info$lost.var
knitr::kable(
  100 * tab1,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (auto). Ideally, all these values should be small (e.g., < 5%).")
# NOTE: no ground (?); this seems like merging plate with adjacent number first !? (i.e. LCE513 + LCE514, + LCE509, LCE508, LCE511, LCE512) (remark: all plates were in the same sequencing run, i.e. NN215)

tab2 <- metadata(mnn_out_2)$merge.info$lost.var
knitr::kable(
  100 * tab2,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")

tab3 <- metadata(mnn_out_3)$merge.info$lost.var
knitr::kable(
  100 * tab3,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")
```

NOTE:
**TODO: double check this note**
Among the 3 merge, the manual merge 2 lead to the least loss of biological variance from the dataset, thus preferred.


```{r}
reducedDim(sce0, "corrected_1") <- reducedDim(mnn_out_1, "corrected")
reducedDim(sce0, "corrected_2") <- reducedDim(mnn_out_2, "corrected")
reducedDim(sce0, "corrected_3") <- reducedDim(mnn_out_3, "corrected")

# generate UMAP
set.seed(18191)
sce0 <- runUMAP(sce0, dimred = "PCA", name = "UMAP")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP")[, 1],
    y = reducedDim(sce0, "UMAP")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_1", name = "UMAP_corrected_1")
corrected_umap_1 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_1")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_1")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_2", name = "UMAP_corrected_2")
corrected_umap_2 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_2")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_2")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_3", name = "UMAP_corrected_3")
corrected_umap_3 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_3")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_3")[, 2]),
  as.data.frame(colData(sce0)))

# re-clustering after each MNN correction
set.seed(4759)
snn_gr_1 <- buildSNNGraph(sce0, use.dimred = "corrected_1")
clusters_1 <- igraph::cluster_louvain(snn_gr_1)
sce0$cluster_1 <- factor(clusters_1$membership)
cluster_colours_1 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_1))],
  levels(sce0$cluster_1))
sce0$colours$cluster_colours_1 <- cluster_colours_1[sce0$cluster_1]

set.seed(4759)
snn_gr_2 <- buildSNNGraph(sce0, use.dimred = "corrected_2")
clusters_2 <- igraph::cluster_louvain(snn_gr_2)
sce0$cluster_2 <- factor(clusters_2$membership)
cluster_colours_2 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_2))],
  levels(sce0$cluster_2))
sce0$colours$cluster_colours_2 <- cluster_colours_2[sce0$cluster_2]

set.seed(4759)
snn_gr_3 <- buildSNNGraph(sce0, use.dimred = "corrected_3")
clusters_3 <- igraph::cluster_louvain(snn_gr_3)
sce0$cluster_3 <- factor(clusters_3$membership)
cluster_colours_3 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_3))],
  levels(sce0$cluster_3))
sce0$colours$cluster_colours_3 <- cluster_colours_3[sce0$cluster_3]
```

```{r batch-correction-test, fig.asp = 1.5, fig.cap = "Comparison between batch-uncorrected and -corrected (by auto and 2 different manual merge orders)", layout="l-page"}

p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")

p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster_1", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_1, name = "cluster_1")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster_2", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_2, name = "cluster_2")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster_3", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_3, name = "cluster_3")

p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")

p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")

p1 + p2 + p3 + p4 +
  p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  p13 + p14 + p15 + p16 +
  p17 + p18 + p19 + p20 +
  p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

```{r batch-correction-test-fixed-cluster, fig.asp = 1/4, fig.cap = "Comparison between batch-uncorrected and -corrected (by auto and 2 different manual merge orders)", layout="l-page"}

# p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# 
# p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")

# NOTE: just to test if the correction can give better resolution than unmerged (by tracing for the change of the original cell grouping)
p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
# comment: seems those "brown cells becoming more scattered after the merge; loss of resolution ? Or brown cells should not forming a cluster in the first place ??

# p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# 
# p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# 
# p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")

# p1 + p2 + p3 + p4 +
#   p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  # p13 + p14 + p15 + p16 +
  # p17 + p18 + p19 + p20 +
  # p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

```{r umap-plate-number, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -plate_number)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

```{r umap-post-hoc-sample-gate, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `post_hoc_sample_gate`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -post_hoc_sample_gate)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

```{r umap-tissue, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `tissue`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -tissue)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

NOTE:
**TODO: double check this note**

  - Blood contains cells mostly from P8 only, whilst thymus contains cells from all 4 phases, i.e. P5, P6, P7 and P8.
  - Cell line seems contain cells in P5, P6, and P8 (not P7)
  - the batch correction may potentially mask the brown cluster in the unmerge data; if is an additional transition phase of P8 (then it is "to keep"), but if the merges help remove unnecessary extra groups (then it is "not to keep") and one should perform MNN; or simply decrease k to increase number of cluster during search of SNNs (as there is obvious plate-based grouping, though it was not picked up by clustering .... !?















## MNN2: All cells (cell line-guiding merge)

We treat each plate as a batch and also test to manually provide the merge order.

**TODO: check if need to treat BOTH plate_number and donor/sample_name as batch !?**

```{r}
sce0 <- sce
```

```{r}
sce0$batch <- sce0$plate_number

var_fit <- modelGeneVarWithSpikes(sce0, "ERCC", block = sce0$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))
```

```{r, results = "hide"}
library(batchelor)
set.seed(1819)

# auto merge
mnn_out_1 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = TRUE,
  restrict = list(sce0$sample_name == "Cell line"), 
  subset.row = hvg)

# manual merge 1
# NOTE: order defined based on the similarities in cell number between plates for each`sample_name`
mnn_out_2 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509"),
  restrict = list(sce0$sample_name == "Cell line"), 
  subset.row = hvg)

# manual merge 2
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_3 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  restrict = list(sce0$sample_name == "Cell line"), 
  subset.row = hvg)
```

One useful diagnostic of the MNN algorithm is the proportion of variance within each batch that is lost during MNN correction^[Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step.].
Large proportions of lost variance ($>10 \%$) suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].

<!-- In this case, the proportion of lost variance is small for most plates, indicating that non-orthogonality is not a major concern, except for the final merges incorporating plates `LC370` and `LC377`. -->
<!-- Loss of some proportion of variance within each batch seems inevitable for these two plates as the experimental groups on these plates are not shared with other plates: -->

<!-- - `LC370` contains the unique `PP.naive.tom+` and `PP.salmon.tom+` groups. -->
<!-- - `LC377` is the most diverse plate in terms of experimental groups and is the only plate containing cells from the `LI.citro.tom-` and `SI.citro.tom-` groups. -->

```{r}
tab1 <- metadata(mnn_out_1)$merge.info$lost.var
knitr::kable(
  100 * tab1,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (auto). Ideally, all these values should be small (e.g., < 5%).")
# NOTE: compare to using all cells to merge, the variance loss is obviously higher in most merge

tab2 <- metadata(mnn_out_2)$merge.info$lost.var
knitr::kable(
  100 * tab2,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")

tab3 <- metadata(mnn_out_3)$merge.info$lost.var
knitr::kable(
  100 * tab3,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")
```

NOTE:
**TODO: double check this note**
Relatively, the manual merge 2 still lead to the least loss of biological variance from the dataset, thus preferred.

```{r}
reducedDim(sce0, "corrected_1") <- reducedDim(mnn_out_1, "corrected")
reducedDim(sce0, "corrected_2") <- reducedDim(mnn_out_2, "corrected")
reducedDim(sce0, "corrected_3") <- reducedDim(mnn_out_3, "corrected")

# generate UMAP
set.seed(18191)
sce0 <- runUMAP(sce0, dimred = "PCA", name = "UMAP")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP")[, 1],
    y = reducedDim(sce0, "UMAP")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_1", name = "UMAP_corrected_1")
corrected_umap_1 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_1")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_1")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_2", name = "UMAP_corrected_2")
corrected_umap_2 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_2")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_2")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_3", name = "UMAP_corrected_3")
corrected_umap_3 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_3")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_3")[, 2]),
  as.data.frame(colData(sce0)))

# re-clustering after each MNN correction
set.seed(4759)
snn_gr_1 <- buildSNNGraph(sce0, use.dimred = "corrected_1")
clusters_1 <- igraph::cluster_louvain(snn_gr_1)
sce0$cluster_1 <- factor(clusters_1$membership)
cluster_colours_1 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_1))],
  levels(sce0$cluster_1))
sce0$colours$cluster_colours_1 <- cluster_colours_1[sce0$cluster_1]

set.seed(4759)
snn_gr_2 <- buildSNNGraph(sce0, use.dimred = "corrected_2")
clusters_2 <- igraph::cluster_louvain(snn_gr_2)
sce0$cluster_2 <- factor(clusters_2$membership)
cluster_colours_2 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_2))],
  levels(sce0$cluster_2))
sce0$colours$cluster_colours_2 <- cluster_colours_2[sce0$cluster_2]

set.seed(4759)
snn_gr_3 <- buildSNNGraph(sce0, use.dimred = "corrected_3")
clusters_3 <- igraph::cluster_louvain(snn_gr_3)
sce0$cluster_3 <- factor(clusters_3$membership)
cluster_colours_3 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_3))],
  levels(sce0$cluster_3))
sce0$colours$cluster_colours_3 <- cluster_colours_3[sce0$cluster_3]
```

```{r batch-correction-test-cell-line-guided, fig.asp = 1.5, fig.cap = "Comparison between batch-uncorrected and -corrected (by auto and 2 different manual merge orders)", layout="l-page"}

p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")

p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster_1", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_1, name = "cluster_1")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster_2", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_2, name = "cluster_2")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster_3", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_3, name = "cluster_3")

p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")

p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")

p1 + p2 + p3 + p4 +
  p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  p13 + p14 + p15 + p16 +
  p17 + p18 + p19 + p20 +
  p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

```{r batch-correction-test-fixed-cluster-cell-line-guided, fig.asp = 1/4, fig.cap = "Comparison between batch-uncorrected and -corrected (by auto and 2 different manual merge orders)", layout="l-page"}

# p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# 
# p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")

# NOTE: just to test if the correction can give better resolution than unmerged (by tracing for the change of the original cell grouping)
p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
# comment: seems those "brown cells becoming more scattered after the merge; loss of resolution ? Or brown cells should not forming a cluster in the first place ??

# p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# 
# p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# 
# p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")

# p1 + p2 + p3 + p4 +
#   p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  # p13 + p14 + p15 + p16 +
  # p17 + p18 + p19 + p20 +
  # p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

```{r umap-plate-number-cell-line-guided, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -plate_number)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

```{r umap-post-hoc-sample-gate-cell-line-guided, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `post_hoc_sample_gate`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -post_hoc_sample_gate)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

```{r umap-tissue-cell-line-guided, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `tissue`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -tissue)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

NOTE:
**TODO: double check this note**

  - auto and manual merge 1 can correct the batch effect, but not manual merge 2 (seems make it even worst)
  - but intriguingly, the clustering for manual merge 2 is not following plate, but show to be orthogonal to the "plate-specific distribution"
  - in terms of conclusion drawn, similar to using all cells, I can still see:
  1) shifting of cells P6 to P7, then P8 in unmerged and even all merges
  2) blood contains cells at the final P8 stage, while thymus contain cells from all 4 stage
  3) small bit of thymus cells seems to transcriptonally superimposed with the SKW3 cell line













## MNN3: Cell line removed (all cells remained-guiding the merge)

We treat each plate as a batch and also test to manually provide the merge order.

**TODO: check if need to treat BOTH plate_number and donor/sample_name as batch !?**

```{r}
sce0 <- sce
```

```{r, results = "hide"}
# subset to remove "Cell line"
sce0 <- sce0[, !(sce0$sample_name == "Cell line")]
droplevels(sce0$sample_name)
```

```{r}
sce0$batch <- sce0$plate_number

var_fit <- modelGeneVarWithSpikes(sce0, "ERCC", block = sce0$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))
```

```{r, results = "hide"}
library(batchelor)
set.seed(1819)

# auto merge
mnn_out_1 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = TRUE,
  subset.row = hvg)

# manual merge 1
# NOTE: order defined based on the similarities in cell number between plates for each`sample_name`
mnn_out_2 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509"),
  subset.row = hvg)

# manual merge 2
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_3 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  subset.row = hvg)
```

One useful diagnostic of the MNN algorithm is the proportion of variance within each batch that is lost during MNN correction^[Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step.].
Large proportions of lost variance ($>10 \%$) suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].

<!-- In this case, the proportion of lost variance is small for most plates, indicating that non-orthogonality is not a major concern, except for the final merges incorporating plates `LC370` and `LC377`. -->
<!-- Loss of some proportion of variance within each batch seems inevitable for these two plates as the experimental groups on these plates are not shared with other plates: -->

<!-- - `LC370` contains the unique `PP.naive.tom+` and `PP.salmon.tom+` groups. -->
<!-- - `LC377` is the most diverse plate in terms of experimental groups and is the only plate containing cells from the `LI.citro.tom-` and `SI.citro.tom-` groups. -->

```{r}
tab1 <- metadata(mnn_out_1)$merge.info$lost.var
knitr::kable(
  100 * tab1,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (auto). Ideally, all these values should be small (e.g., < 5%).")
# NOTE: no ground (?); this seems like merging plate with adjacent number first !? (i.e. LCE513 + LCE514, + LCE509, LCE508, LCE511, LCE512) (remark: all plates were in the same sequencing run, i.e. NN215)

tab2 <- metadata(mnn_out_2)$merge.info$lost.var
knitr::kable(
  100 * tab2,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")

tab3 <- metadata(mnn_out_3)$merge.info$lost.var
knitr::kable(
  100 * tab3,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")
```

NOTE:
**TODO: double check this note**
when `Cell line` is removed from all plates, the variance loss of some merge increase (as a result of loss of cells in common between plates !?), but some decrease instead ... ? But among all, manual merge 2 still work the best !

```{r}
reducedDim(sce0, "corrected_1") <- reducedDim(mnn_out_1, "corrected")
reducedDim(sce0, "corrected_2") <- reducedDim(mnn_out_2, "corrected")
reducedDim(sce0, "corrected_3") <- reducedDim(mnn_out_3, "corrected")

# generate UMAP
set.seed(18191)
sce0 <- runUMAP(sce0, dimred = "PCA", name = "UMAP")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP")[, 1],
    y = reducedDim(sce0, "UMAP")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_1", name = "UMAP_corrected_1")
corrected_umap_1 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_1")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_1")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_2", name = "UMAP_corrected_2")
corrected_umap_2 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_2")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_2")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_3", name = "UMAP_corrected_3")
corrected_umap_3 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_3")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_3")[, 2]),
  as.data.frame(colData(sce0)))

# re-clustering after each MNN correction
set.seed(4759)
snn_gr_1 <- buildSNNGraph(sce0, use.dimred = "corrected_1")
clusters_1 <- igraph::cluster_louvain(snn_gr_1)
sce0$cluster_1 <- factor(clusters_1$membership)
cluster_colours_1 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_1))],
  levels(sce0$cluster_1))
sce0$colours$cluster_colours_1 <- cluster_colours_1[sce0$cluster_1]

set.seed(4759)
snn_gr_2 <- buildSNNGraph(sce0, use.dimred = "corrected_2")
clusters_2 <- igraph::cluster_louvain(snn_gr_2)
sce0$cluster_2 <- factor(clusters_2$membership)
cluster_colours_2 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_2))],
  levels(sce0$cluster_2))
sce0$colours$cluster_colours_2 <- cluster_colours_2[sce0$cluster_2]

set.seed(4759)
snn_gr_3 <- buildSNNGraph(sce0, use.dimred = "corrected_3")
clusters_3 <- igraph::cluster_louvain(snn_gr_3)
sce0$cluster_3 <- factor(clusters_3$membership)
cluster_colours_3 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_3))],
  levels(sce0$cluster_3))
sce0$colours$cluster_colours_3 <- cluster_colours_3[sce0$cluster_3]
```

```{r batch-correction-test-cell-line-removed, fig.asp = 1.5, fig.cap = "Comparison between batch-uncorrected and -corrected (by auto and 2 different manual merge orders)", layout="l-page"}

p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")

p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster_1", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_1, name = "cluster_1")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster_2", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_2, name = "cluster_2")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster_3", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_3, name = "cluster_3")

p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")

p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")

p1 + p2 + p3 + p4 +
  p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  p13 + p14 + p15 + p16 +
  p17 + p18 + p19 + p20 +
  p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

```{r batch-correction-test-fixed-cluster-cell-line-removed, fig.asp = 1/4, fig.cap = "Comparison between batch-uncorrected and -corrected (by auto and 2 different manual merge orders)", layout="l-page"}

# p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = plate_number_colours, name = "plate_number")
# 
# p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")
# p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_name_colours, name = "sample_name")

# NOTE: just to test if the correction can give better resolution than unmerged (by tracing for the change of the original cell grouping)
p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
# comment: seems those "brown cells becoming more scattered after the merge; loss of resolution ? Or brown cells should not forming a cluster in the first place ??

# p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
# 
# p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = tissue_colours, name = "tissue")
# 
# p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")
# p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
#   scale_colour_manual(values = donor_colours, name = "donor")

# p1 + p2 + p3 + p4 +
#   p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  # p13 + p14 + p15 + p16 +
  # p17 + p18 + p19 + p20 +
  # p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

```{r umap-plate-number-cell-line-removed, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -plate_number)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

```{r umap-post-hoc-sample-gate-cell-line-removed, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `post_hoc_sample_gate`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -post_hoc_sample_gate)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

```{r umap-tissue-cell-line-removed, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `tissue`.", fig.asp = 1}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -tissue)

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_1.1, y = UMAP_corrected_1.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_2.1, y = UMAP_corrected_2.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE)
```

NOTE:
**TODO: double check this note**

  - similar conclusion as the previous 2 methods can still be drawn
  - even after cell line was removed from all plate, we can still see a remote cluster, which are cells in `P5`, `P7`, and `P8` (not `P6`) and can be found in both `blood` and `thymus` samples
























### Cluster-specific upregulated genes (unmerge dataset)

We look for genes that are specifically upregulated in each cluster compared to all other clusters.

```{r}
cluster_markers <- findMarkers(
  sce,
  groups = sce$cluster,
  direction = "up",
  pval.type = "all",
  row.data = rowData(sce))
```

Most clusters do not have many genes that are specifically upregulated in that cluster compared to all other clusters ($FDR < 0.05$).

```{r}
print(sapply(cluster_markers, function(x) sum(x$FDR < 0.05)))
```

The heatmaps below highlight the top-50 genes for each cluster.

```{r, fig.asp = 6}
collected <- list()
for (lab in names(cluster_markers)) {
  lab_markers <- cluster_markers[[lab]]
  # NOTE: Select top-50 markers for plotting.
  m <- head(rownames(lab_markers), 50)
  collected[[lab]] <- plotHeatmap(
    object = sce,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample_name", "post_hoc_sample_gate", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample_name = sample_name_colours,
      post_hoc_sample_gate = sample_gate_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours),
    main = lab,
    # annotation_legend = FALSE,
    silent = TRUE)[[4]]
}
wrap_plots(collected, ncol = 1)
```

If we focus on the top 50 cluster-specific marker of cluster 1 and narrow down the heatmap to look only at cells from:
1) cluster 1; or
2) cluster 2 and is from Thymus 2; or 
3) cluster 2 and is from Thymus 3

```{r}
sce1 <- sce[, (sce$cluster == "1") | (sce$cluster == "2" & sce$sample_name == "Thymus 2" | sce$cluster == "2" & sce$sample_name == "Thymus 3" )]

lab_markers <- cluster_markers[[1]]
  # NOTE: Select top-50 markers for plotting.
  m <- head(rownames(lab_markers), 50)
  
 plotHeatmap(
    object = sce1,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample_name", "post_hoc_sample_gate", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample_name = sample_name_colours,
      post_hoc_sample_gate = sample_gate_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours)
    )
```

CSVs of the gene lists are available in [`output/unmerged/cluster_markers`](../output/unmerged/cluster_markers).

```{r}
dir.create(here("output/unmerged/cluster_markers"), recursive = TRUE)
for (n in names(cluster_markers)) {
  message(n)
  gzout <- gzfile(
    description = file.path(
      here("output/unmerged/cluster_markers"),
      sprintf("cluster_%02d.csv.gz", as.integer(n))),
    open = "wb")
  write.csv(
    as.data.frame(flattenDF(cluster_markers[[n]])),
    gzout,
    # NOTE: quote = TRUE needed because some fields contain commas.
    quote = TRUE,
    row.names = TRUE)
  close(gzout)
}
```

































### Cluster-specific upregulated genes (per row)

We look for genes that are specifically upregulated in row P compared to row L, M, N, O of plate LCE511

```{r}
# subset to plate- and row-of-interest
sce2 <- sce[, sce$plate_number == "LCE511" & substr(sce$well_position, 1, 1) %in% c("L", "M", "N", "O", "P")]
sce2$row <- factor(sub("^([[:alpha:]]*).*", "\\1", sce2$well_position))

# set row colours
library(Polychrome)
row_colours <- setNames(
  Polychrome::kelly.colors(nlevels(sce2$row)+1)[-1],
  levels(sce2$row))
sce2$row_colours <- row_colours[sce2$row]
```

```{r}
row_markers <- findMarkers(
  sce2,
  groups = sce2$row,
  direction = "up",
  pval.type = "all",
  row.data = rowData(sce))
```

Most rows do not have many genes that are specifically upregulated in that cluster compared to all other clusters ($FDR < 0.05$).

```{r}
print(sapply(row_markers, function(x) sum(x$FDR < 0.05)))
```

The heatmaps below highlight the top-50 genes for each row

```{r, fig.asp = 6}
collected <- list()
for (lab in names(row_markers)) {
  lab_markers <- row_markers[[lab]]
  # NOTE: Select top-50 markers for plotting.
  m <- head(rownames(lab_markers), 50)
  collected[[lab]] <- plotHeatmap(
    object = sce2,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("row", "cluster", "sample_name", "post_hoc_sample_gate", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      row = row_colours,
      cluster = cluster_colours,
      sample_name = sample_name_colours,
      post_hoc_sample_gate = sample_gate_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours),
    main = lab,
    # annotation_legend = FALSE,
    silent = TRUE)[[4]]
}
wrap_plots(collected, ncol = 1)
```





























```{r}
knitr::knit_exit()
```







<!-- ### Summary -->

<!-- The MNN algorithm returns two sets of corrected values for use in downstream analyses like clustering or visualization: -->

<!-- 1. `corrected`: 'Batch-corrected principal components' -->
<!-- 2. `reconstructed`: 'Batch-corrected expression values' -->

<!-- The `corrected` data contains the low-dimensional corrected coordinates for all cells, which we will use in place of the PCs in our downstream analyses. -->
<!-- The `reconstructed` data contains the corrected expression values for each gene in each cell, obtained by projecting the low-dimensional coordinates in corrected back into gene expression space. -->
<!-- **We do not recommend using the `reconstructed` data for anything other than visualization**^[See [here](https://osca.bioconductor.org/integrating-datasets.html#using-corrected-values) for a detailed explanation of this recommendation.]. -->

<!-- ## Re-processing -->

<!-- We will use the MNN-corrected values in place of the PCs in our downstream analyses, such as UMAP and clustering^[At this point, it is also tempting to use the corrected expression values for gene-based analyses like DE-based marker gene detection. This is not generally recommended as an arbitrary correction algorithm is not obliged to preserve the magnitude (or even direction) of differences in per-gene expression when attempting to align multiple batches.]. -->

<!-- ```{r} -->
<!-- set.seed(853) -->
<!-- sce <- runUMAP(sce, dimred = "corrected") -->
<!-- set.seed(663) -->
<!-- snn_gr <- buildSNNGraph(sce, use.dimred = "corrected") -->
<!-- clusters <- igraph::cluster_louvain(snn_gr) -->
<!-- sce$cluster <- factor(clusters$membership) -->
<!-- cluster_colours <- setNames( -->
<!--   scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))], -->
<!--   levels(sce$cluster)) -->
<!-- sce$cluster_colours <- cluster_colours[sce$cluster] -->
<!-- ``` -->

<!-- There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:mnn-corrected-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:mnn-corrected-cluster-barplot). -->

<!-- ```{r mnn-corrected-clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 2} -->
<!-- p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = cluster), size = 0.25) + -->
<!--   scale_colour_manual(values = cluster_colours) +  -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = plate_number), size = 0.25) + -->
<!--   scale_colour_manual(values = plate_number_colours) +  -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = stimulus), size = 0.25) + -->
<!--   scale_colour_manual(values = stimulus_colours) +  -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = tissue), size = 0.25) + -->
<!--   scale_colour_manual(values = tissue_colours) +  -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p5 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = tomato), size = 0.25) + -->
<!--   scale_colour_manual(values = tomato_colours) +  -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p6 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = sequencing_run), size = 0.25) + -->
<!--   scale_colour_manual(values = sequencing_run_colours) +  -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p7 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = group), size = 0.25) + -->
<!--   # NOTE: Lots of levels, so need smaller font size. -->
<!--   scale_colour_manual(values = group_colours) +  -->
<!--   theme_cowplot(font_size = 6) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- p8 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) + -->
<!--   geom_point(aes(colour = mouse), size = 0.25) + -->
<!--   # NOTE: Lots of levels, so need smaller font size. -->
<!--   scale_colour_manual(values = mouse_colours) +  -->
<!--   theme_cowplot(font_size = 6) +  -->
<!--   xlab("Dimension 1") +  -->
<!--   ylab("Dimension 2") -->
<!-- (p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | p8) -->
<!-- ``` -->

<!-- ```{r mnn-corrected-cluster-barplot, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."} -->
<!-- p1 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = plate_number), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = plate_number_colours) + -->
<!--   # NOTE: Lots of levels, so need smaller font size. -->
<!--   theme_cowplot(font_size = 6) -->
<!-- p2 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = stimulus), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = stimulus_colours) + -->
<!--   theme_cowplot(font_size = 8) -->
<!-- p3 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = tissue), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = tissue_colours) + -->
<!--   theme_cowplot(font_size = 8) -->
<!-- p4 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = tomato), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = tomato_colours) + -->
<!--   theme_cowplot(font_size = 8) -->
<!-- p5 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = sequencing_run), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = sequencing_run_colours) + -->
<!--   theme_cowplot(font_size = 8) -->
<!-- p6 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = group), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = group_colours) + -->
<!--   # NOTE: Lots of levels, so need smaller font size. -->
<!--   theme_cowplot(font_size = 6) -->
<!-- p7 <- ggcells(sce) +  -->
<!--   geom_bar( -->
<!--     aes(x = cluster, fill = mouse), -->
<!--     position = position_fill(reverse = TRUE)) + -->
<!--   coord_flip() + -->
<!--   ylab("Frequency") + -->
<!--   scale_fill_manual(values = mouse_colours) + -->
<!--   # NOTE: Lots of levels, so need smaller font size. -->
<!--   theme_cowplot(font_size = 6) -->
<!-- p8 <- ggcells(sce) +  -->
<!--   geom_bar(aes(x = cluster, fill = cluster)) + -->
<!--   coord_flip() + -->
<!--   ylab("Number of cells") + -->
<!--   scale_fill_manual(values = cluster_colours) + -->
<!--   theme_cowplot(font_size = 8) +  -->
<!--   guides(fill = FALSE) -->
<!-- (p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | p8) -->
<!-- ``` -->

<!-- Notably: -->

<!-- - **Now, none of the clusters are highly `plate_number`-specific. (except LC370 cluster)** -->
<!-- - Now, there are clusters that are somewhat `tissue`-specific, `stimulus`-specific, and `tomato`-specific. -->






# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C133_Pellicci.cells_selected.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C133_Pellicci.cells_selected.SCE.rds`](../data/SCEs/C133_Pellicci.cells_selected.SCE.rds)).
This will be used in downstream analyses, e.g., identifying cluster marker genes and refining the cell labels.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
