---
title: "Selection of biologically relevant cells for Pellicci gamma-delta T-cell dataset"
description: |
author:
  - name: William Ho 
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/rory-bowden/4536/wehi-advanced-genomics-facility
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)
library(pheatmap)
library(janitor)
source(here("code", "helper_functions.R"))
# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))
knitr::opts_chunk$set(fig.path = "C094_Pellicci.cell_selection_files/")
```

# Motivation

scRNA-seq datasets may include cells that are not relevant to the study, even after the initial quality control, which we don't want to include in downstream analyses.
In this section aim to filter out these 'unwanted' cells and retain only the 'biologically relevant' cells.
Examples of unwanted cells include:

- Cells with 'reasonable' QC metrics, but that are transcriptomically distinct from the majority of cells in the dataset
- Cells of unwanted cell types, such as those that might sneak through a FACS or magnetic bead enrichment sample preparation

Once we are confident that we have selected the biologically relevant cells, we will perform data integration (if necessary) and a further round of clustering in preparation for downstream analysis.

The removal of unwanted cells is an iterative process where at each step we:

1. Identify cluster(s) enriched for unwanted cells. The exact criteria used to define 'unwanted' will depend on the type of cells we are trying to identify at each step.
    a. Perform diagnostic checks to ensure we aren't discarding biologically relevant cells.
    b. Remove the unwanted cells.
2. Re-process the remaining cells.
    a. Identify HVGs.
    b. Perform dimensionality reduction (PCA and UMAP).
    c. Cluster cells.
    
<aside>
Throughout, we will exclude mitochondrial genes, ribosomal protein genes, sex chromosome genes, and pseudogenes from the HVGs.
</aside>

Clustering is a critical component of this process, so we discuss it in further detail in the next subsection.

## Clustering

Clustering is an unsupervised learning procedure that is used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles.
Its primary purpose is to summarize the data in a digestible format for human interpretation. 
This allows us to describe population heterogeneity in terms of discrete labels that are easily understood, rather than attempting to comprehend the high-dimensional manifold on which the cells truly reside.
Clustering is thus a critical step for extracting biological insights from scRNA-seq data.

Clustering calculations are usually performed using the top PCs to take advantage of data compression and denoising^[But see the 'Data integration' section of this report for an exception to the rule.].

### Clusters vs. cell types

It is worth stressing the distinction between clusters and cell types.
The former is an empirical construct while the latter is a biological truth (albeit a vaguely defined one).
For this reason, questions like "what is the true number of clusters?" are usually meaningless.
We can define as many clusters as we like, with whatever algorithm we like - each clustering will represent its own partitioning of the high-dimensional expression space, and is as "real" as any other clustering.

A more relevant question is "how well do the clusters approximate the cell types?"
Unfortunately, this is difficult to answer given the context-dependent interpretation of biological truth.
Some analysts will be satisfied with resolution of the major cell types; other analysts may want resolution of subtypes; and others still may require resolution of different states (e.g., metabolic activity, stress) within those subtypes.
Two clusterings can also be highly inconsistent yet both valid, simply partitioning the cells based on different aspects of biology.
Indeed, asking for an unqualified "best" clustering is akin to asking for the best magnification on a microscope without any context.

It is helpful to realize that clustering, like a microscope, is simply a tool to explore the data.
We can zoom in and out by changing the resolution of the clustering parameters, and we can experiment with different clustering algorithms to obtain alternative perspectives of the data.
This iterative approach is entirely permissible for data exploration, which constitutes the majority of all scRNA-seq data analysis.

## Graph-based clustering

We build a shared nearest neighbour graph [@xu2015identification] and use the Louvain algorithm to identify clusters.
We would build the graph using the principal components.

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Preprocessing the Pellicci gamma-delta T-cell data set'](C094_Pellicci.preprocess.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C094_Pellicci.preprocessed.SCE.rds"))
# Some useful colours
sample_type_colours <- setNames(
  unique(sce$colours$sample_type_colours),
  unique(names(sce$colours$sample_type_colours)))
sample_name_colours <- setNames(
  unique(sce$colours$sample_name_colours),
  unique(names(sce$colours$sample_name_colours)))

# NOTE: need to update samplecolours stored in SCE after introducing "post_hoc_sample_gate"
sample_gate_colours <- setNames(
  palette.colors(nlevels(sce$post_hoc_sample_gate), "Tableau 10"),
  levels(sce$post_hoc_sample_gate))
sce$colours$sample_gate_colours <- sample_gate_colours[sce$post_hoc_sample_gate]

plate_number_colours <- setNames(
  unique(sce$colours$plate_number_colours),
  unique(names(sce$colours$plate_number_colours)))
tissue_colours <- setNames(
  unique(sce$colours$tissue_colours),
  unique(names(sce$colours$tissue_colours)))
donor_colours <- setNames(
  unique(sce$colours$donor_colours),
  unique(names(sce$colours$donor_colours)))

# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$gene_symbol)
ribo_set <- intersect(ribo_set, rownames(sce))
sex_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME %in% c("X", "Y"))]
pseudogene_set <- rownames(sce)[
  any(grepl("pseudogene", rowData(sce)$ENSEMBL.GENEBIOTYPE))]
```

## Initial clustering

```{r}
set.seed(4759)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$colours$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot).

```{r clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 1.25}
p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = cluster), size = 0.25) +
  scale_colour_manual(values = cluster_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample_type), size = 0.25) +
  scale_colour_manual(values = sample_type_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample_name), size = 0.25) +
  scale_colour_manual(values = sample_name_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = post_hoc_sample_gate), size = 0.25) +
  scale_colour_manual(values = sample_gate_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p5 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = plate_number), size = 0.25) +
  scale_colour_manual(values = plate_number_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p6 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = tissue), size = 0.25) +
  scale_colour_manual(values = tissue_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p7 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = donor), size = 0.25) +
  scale_colour_manual(values = donor_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

(p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | plot_spacer())
```

```{r cluster-barplot, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample_type),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_type_colours) +
  # NOTE: Lots of levels, so need smaller font size.
  theme_cowplot(font_size = 6)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample_name),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_name_colours) +
  theme_cowplot(font_size = 8)

p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = post_hoc_sample_gate),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_gate_colours) +
  theme_cowplot(font_size = 8)

p4 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)

p5 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = tissue_colours) +
  theme_cowplot(font_size = 8)

p6 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = donor_colours) +
  theme_cowplot(font_size = 8)

(p1 | p2) / (p3 | p4) / (p5 | p6) 
```

*NOTE* for the unmerged data:
  
  - cluster 2, 4, and 6 represent the 3 types/status of cells within P8 and can be found in all blood and thymus samples
  - most of the cells in P5, P6 and P7 form 1 single cluster, i.e. cluster 3, and they found mostly in thymus sample only
  - cluster 1 and 5 are the only standalone clusters separated from the major group (and they seem to be the two obvious clusters needed to be decided if they should "be kept" or "not to be kept" during cell selection step)
  - cluster 1 is basically the control cell line, accompanied with a small amount of cells from thymus 2 and 3
  - cluster 5 are formed from cells mostly from blood 3 and thymus 3 only, implying it was originated from donor 3 only somehow
  - merging or not will be decided based on if the feature above can be preserved/ sharpened

# Data integration

## Motivation

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for common downstream analysis.
However, existing methods based on linear models [@ritchie2015limma;@leek2012sva] assume that the composition of cell populations are either known or the same across batches.
To overcome these limitations, bespoke methods have been developed for batch correction of single-cell data [@haghverdi2018batch;@butler2018integrating;@lin2019scmerge] that do not require a priori knowledge about the composition of the population.
This allows them to be used in workflows for exploratory analyses of scRNA-seq data where such knowledge is usually unavailable.

We will use the Mutual Nearest Neighbours (MNN) approach of @haghverdi2018batch, as implemented in the `r BiocStyle::Biocpkg("batchelor")` package, to perform data integration.
The MNN approach does not rely on pre-defined or equal population compositions across batches, only requiring that a subset of the population be shared between batches.

## MNN correction

We treat each plate as a batch and also test to manually provide the merge order.

```{r}
# backup before test
sce0 <- sce
```

```{r}
sce0$batch <- sce0$plate_number

var_fit <- modelGeneVarWithSpikes(sce0, "ERCC", block = sce0$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))
```

```{r, results = "hide"}
library(batchelor)
set.seed(1819)

# auto merge
# NOTE: auto merge does not make sense; this seems like merging plate with adjacent number first (i.e. LCE513 + LCE514, + LCE509, LCE508, LCE511, LCE512); remark: all plates were in the same sequencing run, i.e. NN215
mnn_out_1 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = TRUE,
  subset.row = hvg)

# manual merge 1
# NOTE: order defined based on the similarities in cell number between plates for each`sample_name`
mnn_out_2 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509"),
  subset.row = hvg)

# manual merge 2
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_3 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  subset.row = hvg)
```

One useful diagnostic of the MNN algorithm is the proportion of variance within each batch that is lost during MNN correction^[Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step.].
Large proportions of lost variance ($>10 \%$) suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].

Among the three merge orders, the *manual merge 2* (Table \@ref(tab:tab3)) lead to the least loss of biological variance from the dataset.

```{r tab1}
tab1 <- metadata(mnn_out_1)$merge.info$lost.var
knitr::kable(
  100 * tab1,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (auto). Ideally, all these values should be small (e.g., < 5%).")
```

```{r tab2}
tab2 <- metadata(mnn_out_2)$merge.info$lost.var
knitr::kable(
  100 * tab2,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual 1). Ideally, all these values should be small (e.g., < 5%).")
```

```{r tab3}
tab3 <- metadata(mnn_out_3)$merge.info$lost.var
knitr::kable(
  100 * tab3,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual 2). Ideally, all these values should be small (e.g., < 5%).")
```

```{r}
reducedDim(sce0, "corrected_1") <- reducedDim(mnn_out_1, "corrected")
reducedDim(sce0, "corrected_2") <- reducedDim(mnn_out_2, "corrected")
reducedDim(sce0, "corrected_3") <- reducedDim(mnn_out_3, "corrected")

# generate UMAP
set.seed(18191)
sce0 <- runUMAP(sce0, dimred = "PCA", name = "UMAP")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP")[, 1],
    y = reducedDim(sce0, "UMAP")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_1", name = "UMAP_corrected_1")
corrected_umap_1 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_1")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_1")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_2", name = "UMAP_corrected_2")
corrected_umap_2 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_2")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_2")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_3", name = "UMAP_corrected_3")
corrected_umap_3 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_3")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_3")[, 2]),
  as.data.frame(colData(sce0)))

# re-clustering after each MNN correction
set.seed(4759)
snn_gr_1 <- buildSNNGraph(sce0, use.dimred = "corrected_1")
clusters_1 <- igraph::cluster_louvain(snn_gr_1)
sce0$cluster_1 <- factor(clusters_1$membership)
cluster_colours_1 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_1))],
  levels(sce0$cluster_1))
sce0$colours$cluster_colours_1 <- cluster_colours_1[sce0$cluster_1]

set.seed(4759)
snn_gr_2 <- buildSNNGraph(sce0, use.dimred = "corrected_2")
clusters_2 <- igraph::cluster_louvain(snn_gr_2)
sce0$cluster_2 <- factor(clusters_2$membership)
cluster_colours_2 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_2))],
  levels(sce0$cluster_2))
sce0$colours$cluster_colours_2 <- cluster_colours_2[sce0$cluster_2]

set.seed(4759)
snn_gr_3 <- buildSNNGraph(sce0, use.dimred = "corrected_3")
clusters_3 <- igraph::cluster_louvain(snn_gr_3)
sce0$cluster_3 <- factor(clusters_3$membership)
cluster_colours_3 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_3))],
  levels(sce0$cluster_3))
sce0$colours$cluster_colours_3 <- cluster_colours_3[sce0$cluster_3]
```

Figure \@ref(fig:batch-correction-test) shows an overview of comparisons between the unmerged and merged (left to right: unmerged, auto, manual merge 1, and manual merge 2) data.

```{r batch-correction-test, fig.asp = 1.5, fig.cap = "Comparison between batch-uncorrected data (leftmost column) and -corrected data by auto merge (2nd column) and two different manual merge orders (3rd and rightmost columns, respectively).", layout="l-page"}

p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")

p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster_1", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_1, name = "cluster_1")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster_2", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_2, name = "cluster_2")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster_3", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_3, name = "cluster_3")

p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")

p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")

p1 + p2 + p3 + p4 +
  p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  p13 + p14 + p15 + p16 +
  p17 + p18 + p19 + p20 +
  p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

To get an insight, here we breakdown the UMAP plot above further by `plate_number` (Figure \@ref(fig:umap-plate-number)), `post_hoc_sample_gate` (Figure \@ref(fig:umap-post-hoc-sample-gate)), and `tissue` (Figure \@ref(fig:umap-tissue)).

From the perspective of correcting the batch effect, the MNN correction can effectively alleviate the plate-specific grouping of cells (Figure \@ref(fig:umap-plate-number)).

From the perspective of preserving the biological-feature-of-interest, after the batch correction, we can still observe: (i) the "shifting" of the transcriptomic stages of cells P6 to P7, then P8 (Figure \@ref(fig:umap-post-hoc-sample-gate)); (ii) Blood contains cells mostly from P8 only, whilst thymus contains cells from all 3 phases, i.e. P6, P7 and P8 (Figure \@ref(fig:umap-tissue)).

```{r umap-plate-number, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -plate_number)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

```{r umap-post-hoc-sample-gate, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `post_hoc_sample_gate` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -post_hoc_sample_gate)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

```{r umap-tissue, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `tissue`when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -tissue)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

Further, we also investigate the usefulness of the control cell line included for batch correction.
The cell line alone, unfortunately, seems not be able to help with the batch correction, but either exacerbated or leave the batch impact unresolved in this scenario (Figure \@ref(fig:umap-plate-number-cell-line-guided-MNN)).

```{r, results = "hide"}
sce1 <- sce

sce1$batch <- sce1$plate_number
var_fit <- modelGeneVarWithSpikes(sce1, "ERCC", block = sce1$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))

library(batchelor)
set.seed(1819)
# auto merge
mnn_out_4 <- fastMNN(
  multiBatchNorm(sce1, batch = sce1$batch),
  batch = sce1$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce1, "PCA")),
  auto.merge = TRUE,
  restrict = list(sce1$sample_name == "Cell line"), 
  subset.row = hvg)
# manual merge 1
# NOTE: order defined based on the similarities in cell number between plates for each`sample_name`
mnn_out_5 <- fastMNN(
  multiBatchNorm(sce1, batch = sce1$batch),
  batch = sce1$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce1, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509"),
  restrict = list(sce1$sample_name == "Cell line"), 
  subset.row = hvg)
# manual merge 2
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_6 <- fastMNN(
  multiBatchNorm(sce1, batch = sce1$batch),
  batch = sce1$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce1, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  restrict = list(sce1$sample_name == "Cell line"), 
  subset.row = hvg)

reducedDim(sce1, "corrected_1") <- reducedDim(mnn_out_4, "corrected")
reducedDim(sce1, "corrected_2") <- reducedDim(mnn_out_5, "corrected")
reducedDim(sce1, "corrected_3") <- reducedDim(mnn_out_6, "corrected")

# generate UMAP
set.seed(18191)
sce1 <- runUMAP(sce1, dimred = "PCA", name = "UMAP")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce1, "UMAP")[, 1],
    y = reducedDim(sce1, "UMAP")[, 2]),
  as.data.frame(colData(sce1)))
set.seed(11901)
sce1 <- runUMAP(sce1, dimred = "corrected_1", name = "UMAP_corrected_1")
corrected_umap_1 <- cbind(
  data.frame(
    x = reducedDim(sce1, "UMAP_corrected_1")[, 1],
    y = reducedDim(sce1, "UMAP_corrected_1")[, 2]),
  as.data.frame(colData(sce1)))
set.seed(11901)
sce1 <- runUMAP(sce1, dimred = "corrected_2", name = "UMAP_corrected_2")
corrected_umap_2 <- cbind(
  data.frame(
    x = reducedDim(sce1, "UMAP_corrected_2")[, 1],
    y = reducedDim(sce1, "UMAP_corrected_2")[, 2]),
  as.data.frame(colData(sce1)))
set.seed(11901)
sce1 <- runUMAP(sce1, dimred = "corrected_3", name = "UMAP_corrected_3")
corrected_umap_3 <- cbind(
  data.frame(
    x = reducedDim(sce1, "UMAP_corrected_3")[, 1],
    y = reducedDim(sce1, "UMAP_corrected_3")[, 2]),
  as.data.frame(colData(sce1)))

# re-clustering after each MNN correction
set.seed(4759)
snn_gr_1 <- buildSNNGraph(sce1, use.dimred = "corrected_1")
clusters_1 <- igraph::cluster_louvain(snn_gr_1)
sce1$cluster_1 <- factor(clusters_1$membership)
cluster_colours_1 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce1$cluster_1))],
  levels(sce1$cluster_1))
sce1$colours$cluster_colours_1 <- cluster_colours_1[sce1$cluster_1]
set.seed(4759)
snn_gr_2 <- buildSNNGraph(sce1, use.dimred = "corrected_2")
clusters_2 <- igraph::cluster_louvain(snn_gr_2)
sce1$cluster_2 <- factor(clusters_2$membership)
cluster_colours_2 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce1$cluster_2))],
  levels(sce1$cluster_2))
sce1$colours$cluster_colours_2 <- cluster_colours_2[sce1$cluster_2]
set.seed(4759)
snn_gr_3 <- buildSNNGraph(sce1, use.dimred = "corrected_3")
clusters_3 <- igraph::cluster_louvain(snn_gr_3)
sce1$cluster_3 <- factor(clusters_3$membership)
cluster_colours_3 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce1$cluster_3))],
  levels(sce1$cluster_3))
sce1$colours$cluster_colours_3 <- cluster_colours_3[sce1$cluster_3]
```

```{r umap-plate-number-cell-line-guided-MNN, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce1)
bg <- dplyr::select(umap_df, -plate_number)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

Also, notably, the SKW3 cell line seems to affect the grouping of some of the sample cells (where cells of cell line were grouped with those from the thymus cell and form a standalone cluster in Figure \@ref(fig:umap-tissue)).
To determine the identity of these cells, we perform cell annotation at cluster level with SingleR using the most relevant annotation reference to gamma-delta T cells- i.e. [Monaco Immune Cell Data (GSE107011)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107011) [@monaco_immuneRef].

## Cell type estimation

Figure \@ref(fig:umap-with-fine-cluster-labels) overlays these cell type labels on the UMAP plot and shows that almost all cells of the big group formed by cluster `2`, `3`, `4` and `6` are corresponds to `Vd2 gd T cells`.
Intriguingly, cluster `5` is annotated as `Intermediate monocytes`, whilst cluster `1` (formed mostly by the SKW3 cell line) is labelled as `Plasmablasts`.

```{r}
library(SingleR)
mi <- MonacoImmuneData()
ref <- mi
labels_fine <- ref$label.fine
label_fine_collapsed_colours <- setNames(
  c(
    Polychrome::glasbey.colors(nlevels(factor(labels_fine)) + 1)[-1],
    "orange"),
  c(levels(factor(labels_fine)), "other"))
```

```{r}
pred_cluster_fine <- SingleR(
  test = sce,
  ref = ref[!grepl("^mt|^Rps|^Rpl", rownames(ref)), ],
  labels = labels_fine,
  cluster = sce$cluster,
  BPPARAM = bpparam())
sce$label_cluster_fine <- factor(pred_cluster_fine$pruned.labels[sce$cluster])
sce$label_cluster_fine_collapsed <- .collapseLabel(
  sce$label_cluster_fine,
  sce$batch)
sce$label_fine_collapsed_colours <- label_fine_collapsed_colours[
  as.character(sce$label_cluster_fine)]
umap_df <- makePerCellDF(sce)
umap_df$label_cluster_fine_collapsed <- sce$label_cluster_fine_collapsed
tabyl(
  data.frame(label.fine = sce$label_cluster_fine, cluster = sce$cluster), 
  cluster, 
  label.fine) %>%
  knitr::kable(
    caption = "Cluster-level assignments using the fine labels of the MI reference.")
```

```{r umap-with-fine-cluster-labels, fig.asp = 2/3, fig.cap = "UMAP plot highlighting clusters (left) and 'fine' cluster-level labels (right) where each panel highlights droplets from a particular label. Labels with < 1% frequency are grouped together as `other`."}
p1 <- ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")
bg <- dplyr::select(umap_df, -label_cluster_fine_collapsed)
p2 <- ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cluster_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cluster_fine_collapsed, ncol = 2) +
  guides(colour = FALSE) + 
  ggtitle("'fine' cluster-level label")
p1 + p2 + plot_layout(widths = c(1, 2))
```

Next, we examine the expression of the marker genes for each label in the test dataset.
We extract the identity of the markers in the reference data sets and use them to create a heatmap of their expression in the test data set.
If a cell in the test dataset is confidently assigned to a particular label, we would expect it to have strong expression of that labelâ€™s markers.

```{r}
all_markers <- metadata(pred_cluster_fine)$de.genes
# Get top-10 marker genes compared to each other cell type
example_label <- "Vd2 gd T cells"
top_markers <- Reduce(union, sapply(all_markers[[example_label]], head, 10))
```

Figures \@ref(fig:heat-mi-fine-markers) demonstrates this for cells labelled as `r example_label`.

```{r heat-mi-fine-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values for the top-10 marker genes of `r example_cluster`. Each column is a sample, each row a gene", fig.asp = 1.5, layout = "l-page"}
library(scater)
plotHeatmap(
  sce,
  features = top_markers,
  columns = order(
    sce$label_cluster_fine_collapsed,
    sce$cluster,
    sce$sample_name,
    sce$plate_number,
    sce$post_hoc_sample_gate,
    sce$tissue,
    sce$donor,
    sce$sample_type),
  colour_columns_by = c(
    "label_cluster_fine_collapsed",
    "cluster",
    "sample_name",
    "plate_number",
    "post_hoc_sample_gate",
    "tissue",
    "donor",
    "sample_type"),
  cluster_cols = FALSE, 
  show_colnames = FALSE,
  main = example_label,
  column_annotation_colors = list(
     label_cluster_fine_collapsed = label_fine_collapsed_colours,
     cluster = cluster_colours,
     sample_name = sample_name_colours,
     plate_number = plate_number_colours,
     post_hoc_sample_gate = sample_gate_colours,
     tissue = tissue_colours,
     donor = donor_colours,
     sample_type = sample_type_colours),
  color = hcl.colors(101, "Blue-Red 3"),
  fontsize = 5)
```

```{r heat-mi-fine-markers-ordered-by-cluster, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values for the top-10 marker genes of `r example_cluster`. Each column is a sample, each row a gene", fig.asp = 1.5, layout = "l-page"}
library(scater)
plotHeatmap(
  sce,
  features = top_markers,
  columns = order(
    sce$cluster,
    sce$label_cluster_fine_collapsed,
    sce$sample_name,
    sce$plate_number,
    sce$post_hoc_sample_gate,
    sce$tissue,
    sce$donor,
    sce$sample_type),
  colour_columns_by = c(
    "cluster",
    "label_cluster_fine_collapsed",
    "sample_name",
    "plate_number",
    "post_hoc_sample_gate",
    "tissue",
    "donor",
    "sample_type"),
  cluster_cols = FALSE, 
  show_colnames = FALSE,
  main = example_label,
  column_annotation_colors = list(
     cluster = cluster_colours,
     label_cluster_fine_collapsed = label_fine_collapsed_colours,
     sample_name = sample_name_colours,
     plate_number = plate_number_colours,
     post_hoc_sample_gate = sample_gate_colours,
     tissue = tissue_colours,
     donor = donor_colours,
     sample_type = sample_type_colours),
  color = hcl.colors(101, "Blue-Red 3"),
  fontsize = 5)
```

At the very least, it should exhibit up-regulation of those markers relative to cells assigned to other labels.
This can be visualized by row-normalizing the data, as done in Figure \@ref(fig:heat-mi-fine-markers-row-normalized).

```{r heat-mi-fine-markers-row-normalized, fig.wide = TRUE, fig.cap = "Heatmap of row-normalized log-expression values for the top-10 marker genes of `r example_cluster`. Each column is a sample, each row a gene. Colours are capped at -3 and 3 to preserve dynamic range.", fig.asp = 1.5, layout = "l-page"}
plotHeatmap(
  sce,
  features = top_markers,
  columns = order(
    sce$label_cluster_fine_collapsed,
    sce$cluster,
    sce$sample_name,
    sce$plate_number,
    sce$post_hoc_sample_gate,
    sce$tissue,
    sce$donor,
    sce$sample_type),
  colour_columns_by = c(
    "label_cluster_fine_collapsed",
    "cluster",
    "sample_name",
    "plate_number",
    "post_hoc_sample_gate",
    "tissue",
    "donor",
    "sample_type"),
  cluster_cols = FALSE, 
  center = TRUE,
  symmetric = TRUE,
  zlim = c(-3, 3),
  show_colnames = FALSE,
  main = example_label,
  column_annotation_colors = list(
     label_cluster_fine_collapsed = label_fine_collapsed_colours,
     cluster = cluster_colours,
     sample_name = sample_name_colours,
     plate_number = plate_number_colours,
     post_hoc_sample_gate = sample_gate_colours,
     tissue = tissue_colours,
     donor = donor_colours,
     sample_type = sample_type_colours),
  fontsize = 5)
```

```{r heat-mi-fine-markers-row-normalized-ordered-by-cluster, fig.wide = TRUE, fig.cap = "Heatmap of row-normalized log-expression values for the top-10 marker genes of `r example_cluster`. Each column is a sample, each row a gene. Colours are capped at -3 and 3 to preserve dynamic range.", fig.asp = 1.5, layout = "l-page"}
plotHeatmap(
  sce,
  features = top_markers,
  columns = order(
    sce$cluster,
    sce$label_cluster_fine_collapsed,
    sce$sample_name,
    sce$plate_number,
    sce$post_hoc_sample_gate,
    sce$tissue,
    sce$donor,
    sce$sample_type),
  colour_columns_by = c(
    "cluster",
    "label_cluster_fine_collapsed",
    "sample_name",
    "plate_number",
    "post_hoc_sample_gate",
    "tissue",
    "donor",
    "sample_type"),
  cluster_cols = FALSE, 
  center = TRUE,
  symmetric = TRUE,
  zlim = c(-3, 3),
  show_colnames = FALSE,
  main = example_label,
  column_annotation_colors = list(
     cluster = cluster_colours,
     label_cluster_fine_collapsed = label_fine_collapsed_colours,
     sample_name = sample_name_colours,
     plate_number = plate_number_colours,
     post_hoc_sample_gate = sample_gate_colours,
     tissue = tissue_colours,
     donor = donor_colours,
     sample_type = sample_type_colours),
  fontsize = 5)
```

Similar figures showing the top-10 marker genes for each label are available in [`output/marker_genes/cell_selection/SingleR/`](../output/marker_genes/cell_selection/SingleR/).

```{r, results = "hide"}
dir.create(here("output", "marker_genes", "cell_selection", "SingleR"))
dev.off() # Needed to ensure next figures save properly.
# NOTE: need to sub the "/" in some of the label or R would misread it as subdirectory !
sce$label_cluster_fine_collapsed <- factor(gsub("/", "_", sce$label_cluster_fine_collapsed))
for (label in setdiff(levels(sce$label_cluster_fine_collapsed), "other")) {
  png(
    here(
      "output",
      "marker_genes",
      "cell_selection",
      "SingleR",
      paste0("MI.", "heatmaps.", label, ".png")),
    width = 10,
    height = 12,
    units = "in",
    res = 250)
  
  top_markers <- Reduce(union, sapply(all_markers[[label]], head, 10))
  
plotHeatmap(
    sce,
    features = top_markers,
    columns = order(
      sce$label_cluster_fine_collapsed,
      sce$cluster,
      sce$sample_name,
      sce$plate_number,
      sce$post_hoc_sample_gate,
      sce$tissue,
      sce$donor,
      sce$sample_type),
    colour_columns_by = c(
      "label_cluster_fine_collapsed",
      "cluster",
      "sample_name",
      "plate_number",
      "post_hoc_sample_gate",
      "tissue",
      "donor",
      "sample_type"),
    cluster_cols = FALSE, 
    show_colnames = FALSE,
    column_annotation_colors = list(
       label_cluster_fine_collapsed = label_fine_collapsed_colours,
       cluster = cluster_colours,
       sample_name = sample_name_colours,
       plate_number = plate_number_colours,
       post_hoc_sample_gate = sample_gate_colours,
       tissue = tissue_colours,
       donor = donor_colours,
       sample_type = sample_type_colours),
    main = label,
    color = hcl.colors(101, "Blue-Red 3"),
    fontsize = 5)
  dev.off()
}

for (label in setdiff(levels(sce$label_cluster_fine_collapsed), "other")) {
  png(
    here(
      "output",
      "marker_genes",
      "cell_selection",
      "SingleR",
      paste0("MI.", "heatmaps_row-normalized.", label, ".png")),
    width = 10,
    height = 12,
    units = "in",
    res = 250)
  
  top_markers <- Reduce(union, sapply(all_markers[[label]], head, 10))
  
plotHeatmap(
    sce,
    features = top_markers,
    columns = order(
      sce$label_cluster_fine_collapsed,
      sce$cluster,
      sce$sample_name,
      sce$plate_number,
      sce$post_hoc_sample_gate,
      sce$tissue,
      sce$donor,
      sce$sample_type),
    colour_columns_by = c(
      "label_cluster_fine_collapsed",
      "cluster",
      "sample_name",
      "plate_number",
      "post_hoc_sample_gate",
      "tissue",
      "donor",
      "sample_type"),
    cluster_cols = FALSE, 
    center = TRUE,
    symmetric = TRUE,
    zlim = c(-3, 3),
    show_colnames = FALSE,
   column_annotation_colors = list(
       label_cluster_fine_collapsed = label_fine_collapsed_colours,
       cluster = cluster_colours,
       sample_name = sample_name_colours,
       plate_number = plate_number_colours,
       post_hoc_sample_gate = sample_gate_colours,
       tissue = tissue_colours,
       donor = donor_colours,
       sample_type = sample_type_colours),
    color = hcl.colors(101, "Blue-Red 3"),
    main = label,
    fontsize = 5)
  
  dev.off()
}
```


```{r, results = "hide"}
dir.create(here("output", "marker_genes", "cell_selection", "SingleR"))
dev.off() # Needed to ensure next figures save properly.
# NOTE: need to sub the "/" in some of the label or R would misread it as subdirectory !
sce$label_cluster_fine_collapsed <- factor(gsub("/", "_", sce$label_cluster_fine_collapsed))
for (label in setdiff(levels(sce$label_cluster_fine_collapsed), "other")) {
  png(
    here(
      "output",
      "marker_genes",
      "cell_selection",
      "SingleR",
      paste0("MI.", "heatmaps.", label, "ordered.by.cluster", ".png")),
    width = 10,
    height = 12,
    units = "in",
    res = 250)
  
  top_markers <- Reduce(union, sapply(all_markers[[label]], head, 10))
  
plotHeatmap(
    sce,
    features = top_markers,
    columns = order(
      sce$cluster,
      sce$label_cluster_fine_collapsed,
      sce$sample_name,
      sce$plate_number,
      sce$post_hoc_sample_gate,
      sce$tissue,
      sce$donor,
      sce$sample_type),
    colour_columns_by = c(
      "cluster",
      "label_cluster_fine_collapsed",
      "sample_name",
      "plate_number",
      "post_hoc_sample_gate",
      "tissue",
      "donor",
      "sample_type"),
    cluster_cols = FALSE, 
    show_colnames = FALSE,
    column_annotation_colors = list(
       cluster = cluster_colours,
       label_cluster_fine_collapsed = label_fine_collapsed_colours,
       sample_name = sample_name_colours,
       plate_number = plate_number_colours,
       post_hoc_sample_gate = sample_gate_colours,
       tissue = tissue_colours,
       donor = donor_colours,
       sample_type = sample_type_colours),
    main = label,
    color = hcl.colors(101, "Blue-Red 3"),
    fontsize = 5)
  dev.off()
}
for (label in setdiff(levels(sce$label_cluster_fine_collapsed), "other")) {
  png(
    here(
      "output",
      "marker_genes",
      "cell_selection",
      "SingleR",
      paste0("MI.", "heatmaps_row-normalized.", label, "ordered.by.cluster", ".png")),
    width = 10,
    height = 12,
    units = "in",
    res = 250)
  
  top_markers <- Reduce(union, sapply(all_markers[[label]], head, 10))
  
plotHeatmap(
    sce,
    features = top_markers,
    columns = order(
      sce$cluster,
      sce$label_cluster_fine_collapsed,
      sce$sample_name,
      sce$plate_number,
      sce$post_hoc_sample_gate,
      sce$tissue,
      sce$donor,
      sce$sample_type),
    colour_columns_by = c(
      "cluster",
      "label_cluster_fine_collapsed",
      "sample_name",
      "plate_number",
      "post_hoc_sample_gate",
      "tissue",
      "donor",
      "sample_type"),
    cluster_cols = FALSE, 
    center = TRUE,
    symmetric = TRUE,
    zlim = c(-3, 3),
    show_colnames = FALSE,
   column_annotation_colors = list(
       cluster = cluster_colours,
       label_cluster_fine_collapsed = label_fine_collapsed_colours,
       sample_name = sample_name_colours,
       plate_number = plate_number_colours,
       post_hoc_sample_gate = sample_gate_colours,
       tissue = tissue_colours,
       donor = donor_colours,
       sample_type = sample_type_colours),
    color = hcl.colors(101, "Blue-Red 3"),
    main = label,
    fontsize = 5)
  
  dev.off()
}
```

**TODO**: based on the SingleR annotation, cluster 5 could potentially be a contaminant (likely be the `intermediate monocytes` from `donor 3`) that sneaked through the FACS gate and could considered to be removed.








## Cluster-specific upregulated genes 

We look for genes that are specifically upregulated in each cluster compared to all other clusters.

```{r}
cluster_markers <- findMarkers(
  sce,
  groups = sce$cluster,
  direction = "up",
  pval.type = "all",
  row.data = rowData(sce))
```

Except for cluster `1`, most clusters do not have many genes that are specifically upregulated in that cluster compared to all other clusters ($FDR < 0.05$).

```{r}
print(sapply(cluster_markers, function(x) sum(x$FDR < 0.05)))
```

The heatmaps below highlight the top-50 genes for each cluster.

```{r heatmap-unique, fig.asp = 6}
collected <- list()
for (lab in names(cluster_markers)) {
  lab_markers <- cluster_markers[[lab]]
  # NOTE: Select top-50 markers for plotting.
  m <- head(rownames(lab_markers), 50)
  collected[[lab]] <- plotHeatmap(
    object = sce,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample_name", "post_hoc_sample_gate", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample_name = sample_name_colours,
      post_hoc_sample_gate = sample_gate_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours),
    main = lab,
    # annotation_legend = FALSE,
    silent = TRUE)[[4]]
}
wrap_plots(collected, ncol = 1)
```

If we zoom-in to the heatmap of the top 50 cluster-specific marker of cluster `1` (Figure \@ref(fig:heatmap-unique-focused)), we may notice that it maybe because of the likewise expression of markers (such as `H2AFZ`, `MIR1244-2`) drive the grouping of the cells from `Thymus 2` and `Thymus 3` with cells from the control cell line in forming the cluster `1`.

```{r heatmap-unique-focused}
sce2 <- sce[, (sce$cluster == "1") | (sce$cluster == "2" & sce$sample_name == "Thymus 2" | sce$cluster == "2" & sce$sample_name == "Thymus 3" )]

lab_markers <- cluster_markers[[1]]
  # NOTE: Select top-50 markers for plotting.
  m <- head(rownames(lab_markers), 50)
  
 plotHeatmap(
    object = sce2,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample_name", "post_hoc_sample_gate", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample_name = sample_name_colours,
      post_hoc_sample_gate = sample_gate_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours)
    )
```

CSVs of the gene lists are available in [`output/unmerged/cluster_markers`](../output/unmerged/cluster_markers).

```{r}
dir.create(here("output/unmerged/cluster_markers"), recursive = TRUE)
for (n in names(cluster_markers)) {
  message(n)
  gzout <- gzfile(
    description = file.path(
      here("output/unmerged/cluster_markers"),
      sprintf("cluster_%02d.csv.gz", as.integer(n))),
    open = "wb")
  write.csv(
    as.data.frame(flattenDF(cluster_markers[[n]])),
    gzout,
    # NOTE: quote = TRUE needed because some fields contain commas.
    quote = TRUE,
    row.names = TRUE)
  close(gzout)
}
```

Taken all of these evidences together, we decide to remove the cell line proceed the analyses with only the sample cells.

```{r}
sce <- sce[, !(sce$sample_name=="Cell line")]
colData(sce) <- droplevels(colData(sce))
```

# Reprocessing

```{r}
sce$batch <- sce$plate_number

var_fit <- modelGeneVarWithSpikes(sce, "ERCC", block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))

set.seed(67726)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(853)
sce <- runUMAP(sce, dimred = "PCA")
set.seed(4759)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$colours$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap-CL-removed) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot-CL-removed).

```{r clusterplot-umap-CL-removed, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 1.25}
p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = cluster), size = 0.25) +
  scale_colour_manual(values = cluster_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample_type), size = 0.25) +
  scale_colour_manual(values = sample_type_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample_name), size = 0.25) +
  scale_colour_manual(values = sample_name_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = post_hoc_sample_gate), size = 0.25) +
  scale_colour_manual(values = sample_gate_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p5 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = plate_number), size = 0.25) +
  scale_colour_manual(values = plate_number_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p6 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = tissue), size = 0.25) +
  scale_colour_manual(values = tissue_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p7 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = donor), size = 0.25) +
  scale_colour_manual(values = donor_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

(p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | plot_spacer())
```

```{r cluster-barplot-CL-removed, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample_type),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_type_colours) +
  # NOTE: Lots of levels, so need smaller font size.
  theme_cowplot(font_size = 6)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample_name),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_name_colours) +
  theme_cowplot(font_size = 8)

p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = post_hoc_sample_gate),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_gate_colours) +
  theme_cowplot(font_size = 8)

p4 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)

p5 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = tissue_colours) +
  theme_cowplot(font_size = 8)

p6 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = donor_colours) +
  theme_cowplot(font_size = 8)

(p1 | p2) / (p3 | p4) / (p5 | p6) 
```

*NOTE* for the unmerged data:
  
  - there are one big and two tiny population
  - the big population is subdivided into four cluster (i.e. cluster `1`, `2`, `3`, and `5`)
  - the two tiny populations is categorized under the same cluster, cluster `4`, which is dominant by cells from `Thymus 3` and `Blood 3`, indicating its `donor_3` origin
  - plate-specific batch effect seems prominent without MNN correction
  - cluster `1` and `2` are mostly cells from `Thymus`
  - except for cells in cluster `1`, cells in all other clusters are mostly in `P8`
  
# Data integration

## MNN correction

We treat each plate as a batch and also test to manually provide the merge order.

```{r}
# backup before test
sce0 <- sce
```

```{r, results = "hide"}
library(batchelor)
set.seed(1819)

# auto merge
# NOTE: auto merge does not make sense; this seems like merging plate with adjacent number first (i.e. LCE513 + LCE514, + LCE509, LCE508, LCE511, LCE512); remark: all plates were in the same sequencing run, i.e. NN215
mnn_out_1 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = TRUE,
  subset.row = hvg)

# manual merge 1
# NOTE: order defined based on the similarities in cell number between plates for each`sample_name`
mnn_out_2 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509"),
  subset.row = hvg)

# manual merge 2
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_3 <- fastMNN(
  multiBatchNorm(sce0, batch = sce0$batch),
  batch = sce0$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce0, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  subset.row = hvg)
```

Among the three merge orders, the *manual merge 2* (Table \@ref(tab:tab3-CL-removed)) lead to the least loss of biological variance from the dataset.

```{r tab1-CL-removed}
tab1 <- metadata(mnn_out_1)$merge.info$lost.var
knitr::kable(
  100 * tab1,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (auto). Ideally, all these values should be small (e.g., < 5%).")
```

```{r tab2-CL-removed}
tab2 <- metadata(mnn_out_2)$merge.info$lost.var
knitr::kable(
  100 * tab2,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual 1). Ideally, all these values should be small (e.g., < 5%).")
```

```{r tab3-CL-removed}
tab3 <- metadata(mnn_out_3)$merge.info$lost.var
knitr::kable(
  100 * tab3,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual 2). Ideally, all these values should be small (e.g., < 5%).")
```

```{r}
reducedDim(sce0, "corrected_1") <- reducedDim(mnn_out_1, "corrected")
reducedDim(sce0, "corrected_2") <- reducedDim(mnn_out_2, "corrected")
reducedDim(sce0, "corrected_3") <- reducedDim(mnn_out_3, "corrected")

# generate UMAP
set.seed(18191)
sce0 <- runUMAP(sce0, dimred = "PCA", name = "UMAP")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP")[, 1],
    y = reducedDim(sce0, "UMAP")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_1", name = "UMAP_corrected_1")
corrected_umap_1 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_1")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_1")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_2", name = "UMAP_corrected_2")
corrected_umap_2 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_2")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_2")[, 2]),
  as.data.frame(colData(sce0)))

set.seed(11901)
sce0 <- runUMAP(sce0, dimred = "corrected_3", name = "UMAP_corrected_3")
corrected_umap_3 <- cbind(
  data.frame(
    x = reducedDim(sce0, "UMAP_corrected_3")[, 1],
    y = reducedDim(sce0, "UMAP_corrected_3")[, 2]),
  as.data.frame(colData(sce0)))

# re-clustering after each MNN correction
set.seed(4759)
snn_gr_1 <- buildSNNGraph(sce0, use.dimred = "corrected_1")
clusters_1 <- igraph::cluster_louvain(snn_gr_1)
sce0$cluster_1 <- factor(clusters_1$membership)
cluster_colours_1 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_1))],
  levels(sce0$cluster_1))
sce0$colours$cluster_colours_1 <- cluster_colours_1[sce0$cluster_1]

set.seed(4759)
snn_gr_2 <- buildSNNGraph(sce0, use.dimred = "corrected_2")
clusters_2 <- igraph::cluster_louvain(snn_gr_2)
sce0$cluster_2 <- factor(clusters_2$membership)
cluster_colours_2 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_2))],
  levels(sce0$cluster_2))
sce0$colours$cluster_colours_2 <- cluster_colours_2[sce0$cluster_2]

set.seed(4759)
snn_gr_3 <- buildSNNGraph(sce0, use.dimred = "corrected_3")
clusters_3 <- igraph::cluster_louvain(snn_gr_3)
sce0$cluster_3 <- factor(clusters_3$membership)
cluster_colours_3 <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce0$cluster_3))],
  levels(sce0$cluster_3))
sce0$colours$cluster_colours_3 <- cluster_colours_3[sce0$cluster_3]
```

Figure \@ref(fig:batch-correction-test-CL-removed) shows an overview of comparisons between the unmerged and merged (left to right: auto, manual 1, and manual 2) data.

```{r batch-correction-test-CL-removed, fig.asp = 1.5, fig.cap = "Comparison between batch-uncorrected data (leftmost column) and -corrected data by auto merge (2nd column) and two different manual merge orders (3rd and rightmost columns, respectively).", layout="l-page"}

p1 <- plotReducedDim(sce0, "UMAP", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p2 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p3 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p4 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p5 <- plotReducedDim(sce0, "UMAP", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p6 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p7 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")
p8 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "sample_name", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_name_colours, name = "sample_name")

p9 <- plotReducedDim(sce0, "UMAP", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p10 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "cluster_1", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_1, name = "cluster_1")
p11 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "cluster_2", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_2, name = "cluster_2")
p12 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "cluster_3", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours_3, name = "cluster_3")

p13 <- plotReducedDim(sce0, "UMAP", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p14 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p15 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")
p16 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "post_hoc_sample_gate", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_gate_colours, name = "post_hoc_sample_gate")

p17 <- plotReducedDim(sce0, "UMAP", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p18 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p19 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p20 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p21 <- plotReducedDim(sce0, "UMAP", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p22 <- plotReducedDim(sce0, "UMAP_corrected_1", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p23 <- plotReducedDim(sce0, "UMAP_corrected_2", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")
p24 <- plotReducedDim(sce0, "UMAP_corrected_3", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")

p1 + p2 + p3 + p4 +
  p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  p13 + p14 + p15 + p16 +
  p17 + p18 + p19 + p20 +
  p21 + p22 + p23 + p24 +
  plot_layout(ncol = 4, guides = "collect")
```

To get an insight, here we breakdown the UMAP plot above further by `plate_number` (Figure \@ref(fig:umap-plate-number-CL-removed)), `post_hoc_sample_gate` (Figure \@ref(fig:umap-post-hoc-sample-gate-CL-removed)), and `tissue` (Figure \@ref(fig:umap-tissue-CL-removed)).

From the perspective of correcting the batch effect, the MNN correction can effectively alleviate the plate-specific grouping of cells (Figure \@ref(fig:umap-plate-number-CL-removed)).

From the perspective of preserving the biological-feature-of-interest, after the batch correction, we can still observe: (i) the "shifting" of the transcriptomic stages of cells P6 to P7, then P8 (Figure \@ref(fig:umap-post-hoc-sample-gate-CL-removed)); (ii) Blood contains cells mostly from P8 only, whilst thymus contains cells from all 3 phases, i.e. P6, P7 and P8 (Figure \@ref(fig:umap-tissue-CL-removed)).

```{r umap-plate-number-CL-removed, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -plate_number)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

```{r umap-post-hoc-sample-gate-CL-removed, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `post_hoc_sample_gate` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -post_hoc_sample_gate)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = post_hoc_sample_gate), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  scale_colour_manual(
    values = sample_gate_colours,
    name = "post_hoc_sample_gate") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~post_hoc_sample_gate, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

```{r umap-tissue-CL-removed, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `tissue`when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}
umap_df <- makePerCellDF(sce0)
bg <- dplyr::select(umap_df, -tissue)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected_3.1, y = UMAP_corrected_3.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

## Cell type estimation

Figure \@ref(fig:umap-with-fine-cluster-labels-CL-removed) overlays these cell type labels on the UMAP plot and shows that almost all cells of the big group formed by cluster `1`, `2`, `3` and `5` are corresponds to `Vd2 gd T cells`.
Intriguingly, cluster `4` is annotated as `Intermediate monocytes`.

```{r}
library(SingleR)
mi <- MonacoImmuneData()
ref <- mi
labels_fine <- ref$label.fine
label_fine_collapsed_colours <- setNames(
  c(
    Polychrome::glasbey.colors(nlevels(factor(labels_fine)) + 1)[-1],
    "orange"),
  c(levels(factor(labels_fine)), "other"))
```

```{r}
pred_cluster_fine <- SingleR(
  test = sce,
  ref = ref[!grepl("^mt|^Rps|^Rpl", rownames(ref)), ],
  labels = labels_fine,
  cluster = sce$cluster,
  BPPARAM = bpparam())
sce$label_cluster_fine <- factor(pred_cluster_fine$pruned.labels[sce$cluster])
sce$label_cluster_fine_collapsed <- .collapseLabel(
  sce$label_cluster_fine,
  sce$batch)
sce$label_fine_collapsed_colours <- label_fine_collapsed_colours[
  as.character(sce$label_cluster_fine)]
umap_df <- makePerCellDF(sce)
umap_df$label_cluster_fine_collapsed <- sce$label_cluster_fine_collapsed
tabyl(
  data.frame(label.fine = sce$label_cluster_fine, cluster = sce$cluster), 
  cluster, 
  label.fine) %>%
  knitr::kable(
    caption = "Cluster-level assignments using the fine labels of the MI reference.")
```

```{r umap-with-fine-cluster-labels-CL-removed, fig.asp = 2/3, fig.cap = "UMAP plot highlighting clusters (left) and 'fine' cluster-level labels (right) where each panel highlights droplets from a particular label. Labels with < 1% frequency are grouped together as `other`."}
p1 <- ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")
bg <- dplyr::select(umap_df, -label_cluster_fine_collapsed)
p2 <- ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cluster_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cluster_fine_collapsed, ncol = 2) +
  guides(colour = FALSE) + 
  ggtitle("'fine' cluster-level label")
p1 + p2 + plot_layout(widths = c(1, 2))
```

**TODO: Again, based on the SingleR annotation, cluster 4 (previously known as "cluster 5") is potentially be a contaminant (intermediate monocytes and is not our interested gamma-delta T cells) that sneaked through the FACS gate and could considered to be removed**

## Cluster-specific upregulated genes 

We look for genes that are specifically upregulated in each cluster compared to all other clusters.

```{r}
cluster_markers <- findMarkers(
  sce,
  groups = sce$cluster,
  direction = "up",
  pval.type = "all",
  row.data = rowData(sce))
```

Except for cluster `1`, `4`, and `5`, all clusters do have number of genes that are specifically upregulated in that cluster compared to all other clusters ($FDR < 0.05$).

```{r}
print(sapply(cluster_markers, function(x) sum(x$FDR < 0.05)))
```

The heatmaps below highlight the top-50 genes for each cluster.

```{r heatmap-unmerged-cluster-unique-markers-CL-removed, fig.asp = 6}
collected <- list()
for (lab in names(cluster_markers)) {
  lab_markers <- cluster_markers[[lab]]
  # NOTE: Select top-50 markers for plotting.
  m <- head(rownames(lab_markers), 50)
  collected[[lab]] <- plotHeatmap(
    object = sce,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample_name", "post_hoc_sample_gate", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample_name = sample_name_colours,
      post_hoc_sample_gate = sample_gate_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours),
    main = lab,
    # annotation_legend = FALSE,
    silent = TRUE)[[4]]
}
wrap_plots(collected, ncol = 1)
```

CSVs of the gene lists are available in [`output/unmerged/cell_line_removed/cluster_markers`](../output/unmerged/cell_line_removed/cluster_markers).

```{r}
dir.create(here("output/unmerged/cell_line_removed/cluster_markers"), recursive = TRUE)
for (n in names(cluster_markers)) {
  message(n)
  gzout <- gzfile(
    description = file.path(
      here("output/unmerged/cell_line_removed/cluster_markers"),
      sprintf("cluster_%02d.csv.gz", as.integer(n))),
    open = "wb")
  write.csv(
    as.data.frame(flattenDF(cluster_markers[[n]])),
    gzout,
    # NOTE: quote = TRUE needed because some fields contain commas.
    quote = TRUE,
    row.names = TRUE)
  close(gzout)
}
```













**TODO: re-write SCE (subset all sample group and cluster removed, if any) and merge before save as RDS !**

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C133_Pellicci.cells_selected.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C133_Pellicci.cells_selected.SCE.rds`](../data/SCEs/C133_Pellicci.cells_selected.SCE.rds)).
This will be used in downstream analyses, e.g., identifying cluster marker genes and refining the cell labels.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
