---
title: "Selection of biologically relevant cells for Pellicci gamma-delta T-cell single-cell dataset"
description: |
author:
  - name: William Ho 
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/rory-bowden/4536/wehi-advanced-genomics-facility
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)
library(pheatmap)
library(janitor)
source(here("code", "helper_functions.R"))
# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))
knitr::opts_chunk$set(fig.path = "C094_Pellicci.single-cell.cell_selection_files/")
```

# Motivation

scRNA-seq datasets may include cells that are not relevant to the study, even after the initial quality control, which we don't want to include in downstream analyses.
In this section aim to filter out these 'unwanted' cells and retain only the 'biologically relevant' cells.
Examples of unwanted cells include:

- Cells with 'reasonable' QC metrics, but that are transcriptomically distinct from the majority of cells in the dataset
- Cells of unwanted cell types, such as those that might sneak through a FACS or magnetic bead enrichment sample preparation

Once we are confident that we have selected the biologically relevant cells, we will perform data integration (if necessary) and a further round of clustering in preparation for downstream analysis.

The removal of unwanted cells is an iterative process where at each step we:

1. Identify cluster(s) enriched for unwanted cells. The exact criteria used to define 'unwanted' will depend on the type of cells we are trying to identify at each step.
    a. Perform diagnostic checks to ensure we aren't discarding biologically relevant cells.
    b. Remove the unwanted cells.
2. Re-process the remaining cells.
    a. Identify HVGs.
    b. Perform dimensionality reduction (PCA and UMAP).
    c. Cluster cells.
    
<aside>
Throughout, we will exclude mitochondrial genes, ribosomal protein genes, sex chromosome genes, and pseudogenes from the HVGs.
</aside>

Clustering is a critical component of this process, so we discuss it in further detail in the next subsection.

## Clustering

Clustering is an unsupervised learning procedure that is used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles.
Its primary purpose is to summarize the data in a digestible format for human interpretation. 
This allows us to describe population heterogeneity in terms of discrete labels that are easily understood, rather than attempting to comprehend the high-dimensional manifold on which the cells truly reside.
Clustering is thus a critical step for extracting biological insights from scRNA-seq data.

Clustering calculations are usually performed using the top PCs to take advantage of data compression and denoising^[But see the 'Data integration' section of this report for an exception to the rule.].

### Clusters vs. cell types

It is worth stressing the distinction between clusters and cell types.
The former is an empirical construct while the latter is a biological truth (albeit a vaguely defined one).
For this reason, questions like "what is the true number of clusters?" are usually meaningless.
We can define as many clusters as we like, with whatever algorithm we like - each clustering will represent its own partitioning of the high-dimensional expression space, and is as "real" as any other clustering.

A more relevant question is "how well do the clusters approximate the cell types?"
Unfortunately, this is difficult to answer given the context-dependent interpretation of biological truth.
Some analysts will be satisfied with resolution of the major cell types; other analysts may want resolution of subtypes; and others still may require resolution of different states (e.g., metabolic activity, stress) within those subtypes.
Two clusterings can also be highly inconsistent yet both valid, simply partitioning the cells based on different aspects of biology.
Indeed, asking for an unqualified "best" clustering is akin to asking for the best magnification on a microscope without any context.

It is helpful to realize that clustering, like a microscope, is simply a tool to explore the data.
We can zoom in and out by changing the resolution of the clustering parameters, and we can experiment with different clustering algorithms to obtain alternative perspectives of the data.
This iterative approach is entirely permissible for data exploration, which constitutes the majority of all scRNA-seq data analysis.

## Graph-based clustering

We build a shared nearest neighbour graph [@xu2015identification] and use the Louvain algorithm to identify clusters.
We would build the graph using the principal components.

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Preprocessing the Pellicci gamma-delta T-cell data set'](C094_Pellicci.preprocess.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C094_Pellicci.single-cell.preprocessed.SCE.rds"))

# Some useful colours
plate_number_colours <- setNames(
  unique(sce$colours$plate_number_colours),
  unique(names(sce$colours$plate_number_colours)))
plate_number_colours <- plate_number_colours[levels(sce$plate_number)]
tissue_colours <- setNames(
  unique(sce$colours$tissue_colours),
  unique(names(sce$colours$tissue_colours)))
tissue_colours <- tissue_colours[levels(sce$tissue)]
donor_colours <- setNames(
  unique(sce$colours$donor_colours),
  unique(names(sce$colours$donor_colours)))
donor_colours <- donor_colours[levels(sce$donor)]
sample_colours <- setNames(
  unique(sce$colours$sample_colours),
  unique(names(sce$colours$sample_colours)))
sample_colours <- sample_colours[levels(sce$sample)]
stage_colours <- setNames(
  unique(sce$colours$stage_colours),
  unique(names(sce$colours$stage_colours)))
stage_colours <- stage_colours[levels(sce$stage)]

# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$gene_symbol)
ribo_set <- intersect(ribo_set, rownames(sce))
sex_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME %in% c("X", "Y"))]
pseudogene_set <- rownames(sce)[
  any(grepl("pseudogene", rowData(sce)$ENSEMBL.GENEBIOTYPE))]
```

## Initial clustering

```{r}
set.seed(4759)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$colours$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot).

```{r clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 1.25}
p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = cluster), size = 0.25) +
  scale_colour_manual(values = cluster_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample), size = 0.25) +
  scale_colour_manual(values = sample_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = plate_number), size = 0.25) +
  scale_colour_manual(values = plate_number_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = tissue), size = 0.25) +
  scale_colour_manual(values = tissue_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p5 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = donor), size = 0.25) +
  scale_colour_manual(values = donor_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

(p1 | p2) / (p3 | p4) / (p5 | plot_spacer())
```

```{r cluster-barplot, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_colours) +
  theme_cowplot(font_size = 8)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = stage),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = stage_colours) +
  theme_cowplot(font_size = 8)

p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)

p4 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = tissue_colours) +
  theme_cowplot(font_size = 8)

p5 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = donor_colours) +
  theme_cowplot(font_size = 8)

(p1 | p2) / (p3 | p4) / (p5 | plot_spacer()) 
```

**NOTE** for the unmerged data based on these figures:
  
  - the majority of cells in cluster `3` and `4` represent the three types/statuses of cells at `S3` and can be found in both `Blood` and `Thymus` samples
  - most of the cells in `P6` and `P7` form one single cluster, i.e. cluster `2`, and they found mostly in `Thymus` sample only
  - cluster `1` and `5` are the only standalone clusters separated from the major group (and they seem to be the two obvious clusters needed to be decided if they should "be kept" or "not to be kept" during cell selection step)
  - cluster `1` is basically the control cell line `SKW3`, accompanied with a small amount of cells from `Thymus 2` and `Thymus 3`
  - cluster `5` are formed from cells mostly from `Blood 3` and `Thymus 3` only, implying it was originated from donor `3` only somehow
  - merging or not will be decided based on if the feature above can be preserved or not

## Investigation of cluster `5`

## Cell type estimation

First of all, to get a general idea about the identity of cells contained in the strayed cluster `5`, we perform cell annotation at cluster level with SingleR using the most relevant annotation reference to gamma-delta T cells- i.e. [Monaco Immune Cell Data (GSE107011)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107011) [@monaco_immuneRef].

Figure \@ref(fig:umap-with-fine-cluster-labels) overlays these cell-type-labels on the UMAP plot and it shows that almost all cells of the bigger group formed by cluster `2`, `3`, and `4`are corresponds to `Vd2 gd T cells`.
Intriguingly, cluster `5` is annotated as `Intermediate monocytes`, whilst cluster `1` (formed mostly by the SKW3 cell line) is labelled as `Plasmablasts`.

```{r}
library(SingleR)
library(celldex)
mi <- MonacoImmuneData()
ref <- mi
labels_fine <- ref$label.fine
label_fine_collapsed_colours <- setNames(
  c(
    Polychrome::glasbey.colors(nlevels(factor(labels_fine)) + 1)[-1],
    "orange"),
  c(levels(factor(labels_fine)), "other"))
```

```{r}
pred_cluster_fine <- SingleR(
  test = sce,
  ref = ref[!grepl("^mt|^Rps|^Rpl", rownames(ref)), ],
  labels = labels_fine,
  cluster = sce$cluster,
  BPPARAM = bpparam())
sce$label_cluster_fine <- factor(pred_cluster_fine$pruned.labels[sce$cluster])
sce$label_cluster_fine_collapsed <- .collapseLabel(
  sce$label_cluster_fine,
  sce$batch)
sce$label_fine_collapsed_colours <- label_fine_collapsed_colours[
  as.character(sce$label_cluster_fine)]
umap_df <- makePerCellDF(sce)
umap_df$label_cluster_fine_collapsed <- sce$label_cluster_fine_collapsed
tabyl(
  data.frame(label.fine = sce$label_cluster_fine, cluster = sce$cluster), 
  cluster, 
  label.fine) %>%
  knitr::kable(
    caption = "Cluster-level assignments using the fine labels of the MI reference.")
```

```{r umap-with-fine-cluster-labels, fig.asp = 2/3, fig.cap = "UMAP plot highlighting clusters (left) and 'fine' cluster-level labels (right) where each panel highlights droplets from a particular label. Labels with < 1% frequency are grouped together as `other`."}
p1 <- ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")
bg <- dplyr::select(umap_df, -label_cluster_fine_collapsed)
p2 <- ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cluster_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cluster_fine_collapsed, ncol = 2) +
  guides(colour = FALSE) + 
  ggtitle("'fine' cluster-level label")
p1 + p2 + plot_layout(widths = c(1, 2))
```

##### Diagnostic plots

As a sanity check, we can examine the expression of the marker genes for the relevant cell type labels by plotting a heatmap of their expression in:

1. The reference dataset
2. Our dataset

The value of (1) is that we can assess if we believe the genes are indeed good markers of the relevant cell type in the reference dataset.
The value of (2) is that we can check that these genes are useful markers in our dataset (e.g., that they are reasonably well sampled in our data).

```{r}
monocyte_vs_gtT_markers <- metadata(
  pred_cluster_fine)$de.genes$`Intermediate monocytes`$`Vd2 gd T cells`
gdT_vs_monocyte_markers <- metadata(
  pred_cluster_fine)$de.genes$`Vd2 gd T cells`$`Intermediate monocytes`
markers <- c(
  head(monocyte_vs_gtT_markers, 10),
  head(gdT_vs_monocyte_markers, 10))
```

Here, we specifically select (some of) the most strongly upregulated genes when comparing the `Intermediate monocytes` to the `Vd2 gd T cells` (`mi.Mono_vs_gdT`) and vice-versa (`mi.gdT_vs_Mono`)

Figure \@ref(fig:ref-mi-mono-and-gdT-markers) confirms that both the `mi.Mono_vs_gdT` and `mi.gdT_vs_Mono` marker genes distinguish these two cell types from one another in the `MI` reference dataset.
However, the `mi.gdT_vs_Mono` marker genes are also expressed in `Plasmablasts` samples, highlighting that what are useful marker genes in one comparison are not necessarily in another comparison.

```{r ref-mi-mono-and-gdT-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in the `MI` reference dataset for selected marker genes between the `Intermediate monocytes` and `Vd2 gd T cells` labels. Each column is a sample, each row a gene", fig.asp = 1.1}
# NOTE: Have to remove column names from MI to avoid an error.
tmp <- mi
colnames(tmp) <- seq_len(ncol(tmp))

# select only the annotation used in this dataset
tmp <- tmp[,tmp$label.fine==levels(sce$label_cluster_fine)]

# specify a more contrasting colour than default
# TODO: `row_annotation_colors` seems still not able to pass the colours to the plotHeatmap function
markers_colours <- setNames(c("red", "green"), c("mi.Mono_vs_gdT", "mi.gdT_vs_Mono"))

plotHeatmap(
  tmp,
  features = markers,
  colour_columns_by = "label.fine",
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = "label.fine",
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("mi.Mono_vs_gdT", 10), rep("mi.gdT_vs_Mono", 10)),
    row.names = markers),
  color = hcl.colors(101, "Blue-Red 3"),
  column_annotation_colors = list(
    label.fine = label_fine_collapsed_colours[levels(sce$label_cluster_fine)]),
  row_annotation_colors = list(
    markers = markers_colours)
  )
```

As you can see, the cells from cluster `5` do give a very strong expression of the `intermediate monocyte` markers, whilst cells from the other three "gamma-delta T cells"-labelled clusters do not.
Although the other three clusters labelled as `Vd2 gd T cells` do not give a very strong expression of those T cells markers (possibly due to the fact that they are mostly be the "developing" gamma-delta T cells rather than "mature" ones used by the `SingleR` reference), the cluster `5` cells do give a relatively lower expression for most of the "gamma-delta T cells" markers compared to the other three clusters.
Therefore, it suggests the likelihood that the cells in cluster `5` could really be the `intermediate monocyte` and less likely be the `Vd2 gd T cells`.

```{r test-mi-mono-and-gdT-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for selected marker genes between the `Intermediate monocytes` and `Vd2 gd T cells` labels. Each column is a sample, each row a gene. For legibility, only a random 10% of non-`Intermediate monocytes` cells are shown.", fig.asp = 1.1}

tmp <- logNormCounts(
  sumCountsAcrossCells(
    sce,
    ids = colData(sce)[, c("cluster", "label_cluster_fine")],
    subset_row = markers), exprs_values = 1)

plotHeatmap(
  tmp,
  features = markers,
  colour_columns_by = c("label_cluster_fine", "cluster"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("label_cluster_fine", "cluster"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("mi.Mono_vs_gdT", 10), rep("mi.gdT_vs_Mono", 10)),
    row.names = markers),
  color = hcl.colors(101, "Blue-Red 3"),
  column_annotation_colors = list(
    cluster = cluster_colours,
    label_cluster_fine = label_fine_collapsed_colours[
      levels(sce$label_cluster_fine)]))
```

## Cluster-specific upregulated genes

Further, we also look for genes that are specifically upregulated in cluster `5` compared to all other clusters, so as to help determine the exact identity of the cluster.

```{r}
cluster_markers <- findMarkers(
  sce,
  groups = sce$cluster,
  direction = "up",
  pval.type = "all",
  row.data = rowData(sce))
```

Cluster `5` shows to possess handful of genes that are specifically upregulated in that cluster compared to all other clusters ($FDR < 0.05$).

```{r}
print(sapply(cluster_markers, function(x) sum(x$FDR < 0.05)))
```

The heatmaps below highlight the top-50 genes for cluster `5`.

```{r heatmap-unique-cluster-5, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for cluster-specific marker with FDR <0.05. Each column is a cell, each row a gene. For legibility", fig.asp = 1.25}
lab <- "5"
m <- rownames(cluster_markers[[lab]])[cluster_markers[[lab]]$FDR < 0.05]

plotHeatmap(
    object = sce,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample", "stage", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample = sample_colours,
      stage = stage_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours,
    main = lab)
    )
```

## Investigation of cluster `1` 

## Cluster-specific upregulated genes

We look for genes that are specifically upregulated in cluster `1` compared to all other clusters.

The heatmaps below highlight the top-50 genes for cluster `1`.

```{r heatmap-unique-cluster-1, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for cluster-specific marker with FDR <0.05. Each column is a cell, each row a gene. For legibility", fig.asp = 1.25}

lab <- "1"
lab_markers <- rownames(cluster_markers[[lab]])[cluster_markers[[lab]]$FDR < 0.05]
# NOTE: Select top-50 markers for plotting.
m <- head(lab_markers, 50)

plotHeatmap(
    object = sce,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample", "stage", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample = sample_colours,
      stage = stage_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours,
    main = lab)
    )
```

If we zoom-in to the heatmap above, we may notice that there is a number of likewise expression of cluster `1` specific markers (such as `PTMA`, `MIR1244-2`) between the cells from `Thymus 2` and `Thymus 3` with those of  the control cell line.
As a result, this may drive the grouping of the cells between thymus cells and the control cell line, which lead to the formation of cluster `1`.

```{r heatmap-unique-focused-cluster-1}
sce1 <- sce[, (sce$cluster == "1") | (sce$cluster == "2" & sce$sample == "Thymus 2" | sce$cluster == "2" & sce$sample == "Thymus 3" )]

lab <- "1"
lab_markers <- rownames(cluster_markers[[lab]])[cluster_markers[[lab]]$FDR < 0.05]
# NOTE: Select top-50 markers for plotting.
m <- head(lab_markers, 50)
  
 plotHeatmap(
    object = sce1,
    features = m,
    color = hcl.colors(101, "Blue-Red 3"),
    center = TRUE,
    zlim = c(-3, 3),
    order_columns_by = c("cluster", "sample", "stage", "plate_number", "tissue", "donor"),
    cluster_rows = TRUE,
    fontsize = 5,
    column_annotation_colors = list(
      cluster = cluster_colours,
      sample = sample_colours,
      stage = stage_colours,
      plate_number = plate_number_colours,
      tissue = tissue_colours,
      donor = donor_colours)
    )
```

CSVs of the gene lists of unique markers for each cluster are available in [`output/unmerged/cluster_markers`](../output/unmerged/cluster_markers).

```{r}
dir.create(here("output/unmerged/cluster_markers"), recursive = TRUE)
for (n in names(cluster_markers)) {
  message(n)
  gzout <- gzfile(
    description = file.path(
      here("output/unmerged/cluster_markers"),
      sprintf("cluster_%02d.csv.gz", as.integer(n))),
    open = "wb")
  write.csv(
    as.data.frame(flattenDF(cluster_markers[[n]])),
    gzout,
    # NOTE: quote = TRUE needed because some fields contain commas.
    quote = TRUE,
    row.names = TRUE)
  close(gzout)
}
```

## Cell line-guided batch correction

Further, we also investigate the usefulness of the control cell line `SKW3` in cluster `1` for purpose of batch correction.
The cell line alone, unfortunately, seems not be sufficient to help with the batch correction, but either exacerbated or leave the batch impact unresolved in this scenario (Figure \@ref(fig:umap-plate-number-cell-line-guided-MNN)).

```{r, results = "hide"}
tmp <- sce

tmp$batch <- tmp$plate_number
var_fit <- modelGeneVarWithSpikes(tmp, "ERCC", block = tmp$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))

library(batchelor)
set.seed(1819)

# manual merge 
# NOTE: to reduced var loss of LCE509, which contained different proportion of cells from each sample, I decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out_0 <- fastMNN(
  multiBatchNorm(tmp, batch = tmp$batch),
  batch = tmp$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(tmp, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  restrict = list(tmp$tissue == "SKW3"), 
  subset.row = hvg)

reducedDim(tmp, "corrected") <- reducedDim(mnn_out_0, "corrected")

# generate UMAP
set.seed(11901)
tmp <- runUMAP(tmp, dimred = "corrected", name = "UMAP_corrected")
```

```{r umap-plate-number-cell-line-guided-MNN, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}
umap_df <- makePerCellDF(tmp)
bg <- dplyr::select(umap_df, -plate_number)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected.1, y = UMAP_corrected.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP_corrected 1") +
  ylab("UMAP_corrected 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

Notably, the `SKW3` cell line also seems to affect the grouping of some of the sample cells (where cells of cell line were grouped with those from the `Thymus` cells and form a standalone cluster.

**NOTE**: Taken all of these evidences together, we decide to remove the `Cell line` proceed the analyses with only the sample cells.
Also, after our online discussion with Dan and Stuart on 30 June 2021, we confirmed that cells in cluster `5` are contaminants and should be removed from the the subsequent analyses as well.

```{r}
# remove `cell line` and cells from cluster
sce <- sce[, !(sce$tissue=="SKW3")]
sce <- sce[, !(sce$cluster=="5")]
colData(sce) <- droplevels(colData(sce))
```

We then re-process the *sample cells* remained in the dataset.

### Re-processing

```{r}
sce$batch <- sce$plate_number
var_fit <- modelGeneVarWithSpikes(sce, "ERCC", block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
hvg <- setdiff(hvg, c(ribo_set, mito_set, pseudogene_set))

set.seed(67726)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(853)
sce <- runUMAP(sce, dimred = "PCA")

set.seed(4759)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$colours$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap-cell-selected) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot-cell-selected).

```{r clusterplot-umap-cell-selected, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 1.25}
p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = cluster), size = 0.25) +
  scale_colour_manual(values = cluster_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sample), size = 0.25) +
  scale_colour_manual(values = sample_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = stage), size = 0.25) +
  scale_colour_manual(values = stage_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = plate_number), size = 0.25) +
  scale_colour_manual(values = plate_number_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p5 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = tissue), size = 0.25) +
  scale_colour_manual(values = tissue_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

p6 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = donor), size = 0.25) +
  scale_colour_manual(values = donor_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

(p1 | p2) / (p3 | p4) / (p5 | p6)
```

```{r cluster-barplot-cell-selected, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_colours) +
  theme_cowplot(font_size = 8)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = stage),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = stage_colours) +
  theme_cowplot(font_size = 8)

p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)

p4 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = tissue_colours) +
  theme_cowplot(font_size = 8)

p5 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = donor_colours) +
  theme_cowplot(font_size = 8)

(p1 | p2) / (p3 | p4) / (p5 | plot_spacer()) 
```

*NOTE* for the unmerged data:
  
  - there is one big population, which is subdivided into four clusters (i.e. cluster `1`, `2`, `3`, and `4`)
  - cells in cluster `1`, `3`, and `4` are mostly in `P8`, whilst cells in cluster `2` are mostly be mixture of `P6`, `P7`, and `P8` 
  - plate-specific batch effect seems prominent without MNN correction

# Data integration

## Motivation

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for common downstream analysis.
However, existing methods based on linear models [@ritchie2015limma;@leek2012sva] assume that the composition of cell populations are either known or the same across batches.
To overcome these limitations, bespoke methods have been developed for batch correction of single-cell data [@haghverdi2018batch;@butler2018integrating;@lin2019scmerge] that do not require a priori knowledge about the composition of the population.
This allows them to be used in workflows for exploratory analyses of scRNA-seq data where such knowledge is usually unavailable.

We will use the Mutual Nearest Neighbours (MNN) approach of @haghverdi2018batch, as implemented in the `r BiocStyle::Biocpkg("batchelor")` package, to perform data integration.
The MNN approach does not rely on pre-defined or equal population compositions across batches, only requiring that a subset of the population be shared between batches.

## MNN correction

We treat each plate as a batch and also test to manually provide the merge order.

```{r, results = "hide"}
library(batchelor)
set.seed(1819)

# manual merge
# NOTE: we tried a merge order (list(list("LCE508", "LCE511", "LCE512", "LCE513", "LCE514"), "LCE509")), which led to significant variance loss; to reduced var loss of LCE509, which contained different proportion of cells from each sample, we decide to merge LCE509 after the merge of LCE503 + LCE504 (as indicated in the auto-merge)
mnn_out <- fastMNN(
  multiBatchNorm(sce, batch = sce$batch),
  batch = sce$batch,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce, "PCA")),
  auto.merge = FALSE,
  merge.order = list(list("LCE513", "LCE514", "LCE509"), list("LCE508", "LCE511", "LCE512")),
  subset.row = hvg)
```

One useful diagnostic of the MNN algorithm is the proportion of variance within each batch that is lost during MNN correction^[Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step.].
Large proportions of lost variance ($>10 \%$) suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].

The *manual merge order* we chosen (Table \@ref(tab:tab-cell-selected)) lead to an acceptable loss of biological variance from the dataset.

```{r tab-cell-selected}
tab <- metadata(mnn_out)$merge.info$lost.var
knitr::kable(
  100 * tab,
  digits = 1,
  caption = "Percentage of estimated biological variation lost within each plate at each step of the merge (manual). Ideally, all these values should be small (e.g., < 5%).")
```

```{r}
reducedDim(sce, "corrected") <- reducedDim(mnn_out, "corrected")

# generate UMAP
set.seed(1248)
sce <- runUMAP(sce, dimred = "corrected", name = "UMAP_corrected")

# re-clustering after each MNN correction
set.seed(4759)

snn_gr <- buildSNNGraph(sce, use.dimred = "corrected")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$colours$cluster_colours <- cluster_colours[sce$cluster]
```

Figure \@ref(fig:batch-correction-test-cell-selected) shows an overview of comparisons between the unmerged and merged data  (*manual merge*) broken down by different experimental factors.

```{r batch-correction-test-cell-selected, fig.asp = 1.5, fig.cap = "Comparison between batch-uncorrected data (leftmost column) and -corrected data by auto merge (2nd column) and two different manual merge orders (3rd and rightmost columns, respectively)."}

p1 <- plotReducedDim(sce, "UMAP", colour_by = "plate_number") + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")
p2 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "plate_number") + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p3 <- plotReducedDim(sce, "UMAP", colour_by = "sample") + 
  scale_colour_manual(values = sample_colours, name = "sample")
p4 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "sample") + 
  scale_colour_manual(values = sample_colours, name = "sample")

p5 <- plotReducedDim(sce, "UMAP", colour_by = "cluster") + 
  scale_colour_manual(values = cluster_colours, name = "cluster")
p6 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "cluster") + 
  scale_colour_manual(values = cluster_colours, name = "cluster")

p7 <- plotReducedDim(sce, "UMAP", colour_by = "stage") + 
  scale_colour_manual(values = stage_colours, name = "stage")
p8 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "stage") + 
  scale_colour_manual(values = stage_colours, name = "stage")

p9 <- plotReducedDim(sce, "UMAP", colour_by = "tissue") + 
  scale_colour_manual(values = tissue_colours, name = "tissue")
p10 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "tissue") + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p11 <- plotReducedDim(sce, "UMAP", colour_by = "donor") + 
  scale_colour_manual(values = donor_colours, name = "donor")
p12 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "donor") + 
  scale_colour_manual(values = donor_colours, name = "donor")

p1 + p2 + p3 + p4 +
  p5 + p6 + p7 + p8 +
  p9 + p10 + p11 + p12 +
  plot_layout(ncol = 2, guides = "collect")
```

To get an insight, here we focus on the uncorrected and the corrected data by the *manual merge*, then break down the UMAP plot above further by `plate_number` (Figure \@ref(fig:umap-plate-number-cell-selected)), `stage` (Figure \@ref(fig:umap-post-hoc-sample-gate-cell-selected)), and `tissue` (Figure \@ref(fig:umap-tissue-cell-selected)).

From the perspective of correcting the batch effect, the MNN correction can effectively alleviate the plate-specific grouping of cells (Figure \@ref(fig:umap-plate-number-cell-selected)).

From the perspective of preserving the biological-feature-of-interest, after the batch correction, we can still observe: (i) the "shifting" of the transcriptomic stages of cells `P6` to `P7`, then `P8` (Figure \@ref(fig:umap-post-hoc-sample-gate-cell-selected)); (ii) `Blood` contains cells mostly at `P8` only, whilst `Thymus` contains cells at all three phases, i.e. `P6`, `P7` and `P8` (Figure \@ref(fig:umap-tissue-cell-selected)).

```{r umap-plate-number-cell-selected, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `plate_number` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce)
bg <- dplyr::select(umap_df, -plate_number)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected.1, y = UMAP_corrected.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = plate_number), alpha = 1, size = 0.5) +
  scale_fill_manual(values = plate_number_colours, name = "plate_number") +
  scale_colour_manual(values = plate_number_colours, name = "plate_number") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~plate_number, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

```{r umap-post-hoc-sample-gate-cell-selected, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `stage` when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 3/4, layout="l-body"}

umap_df <- makePerCellDF(sce)
bg <- dplyr::select(umap_df, -stage)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = stage), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = stage_colours,
    name = "stage") +
  scale_colour_manual(
    values = stage_colours,
    name = "stage") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~stage, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected.1, y = UMAP_corrected.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = stage), alpha = 1, size = 0.5) +
  scale_fill_manual(
    values = stage_colours,
    name = "stage") +
  scale_colour_manual(
    values = stage_colours,
    name = "stage") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~stage, ncol = 3) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

```{r umap-tissue-cell-selected, fig.cap = "UMAP plot of the dataset. Each point represents a cell and each panel highlights cells from a particular `tissue`when data is unmerged (left) and merged by manual merge 2 (right).", fig.asp = 2/3, layout="l-body"}
umap_df <- makePerCellDF(sce)
bg <- dplyr::select(umap_df, -tissue)

plot_grid(

ggplot(aes(x = UMAP.1, y = UMAP.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ggplot(aes(x = UMAP_corrected.1, y = UMAP_corrected.2), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(aes(colour = tissue), alpha = 1, size = 0.5) +
  scale_fill_manual(values = tissue_colours, name = "tissue") +
  scale_colour_manual(values = tissue_colours, name = "tissue") +
  theme_cowplot(font_size = 10) +
  xlab("UMAP 1") +
  ylab("UMAP 2") +
  facet_wrap(~tissue, ncol = 2) +
  guides(colour = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  guides(colour = FALSE),

ncol= 2,
align ="h"
)
```

Taken altogether, we conclude that the data corrected by the *manual merge* as the best possible merge order for data integration of this dataset and proceed.

```{r}
reducedDim(sce, "corrected") <- reducedDim(mnn_out, "corrected")
```

```{r}
set.seed(1248)
sce <- runUMAP(sce, dimred = "corrected", name = "UMAP_corrected")

set.seed(4759)
snn_gr <- buildSNNGraph(sce, use.dimred = "corrected")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
cluster_colours <- setNames(
  scater:::.get_palette("tableau10medium")[seq_len(nlevels(sce$cluster))],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

To sumup, there are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap-cell-selected-merged) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot-cell-selected-merged).

```{r clusterplot-umap-cell-selected-merged, fig.cap = "UMAP plot, where each point represents a cell and is coloured according to the legend.", fig.asp = 1.25}
p1 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "cluster", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = cluster_colours, name = "cluster")

p2 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "sample", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = sample_colours, name = "sample")

p3 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "stage", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = stage_colours, name = "stage")

p4 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "plate_number", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = plate_number_colours, name = "plate_number")

p5 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "tissue", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = tissue_colours, name = "tissue")

p6 <- plotReducedDim(sce, "UMAP_corrected", colour_by = "donor", theme_size = 7, point_size = 0.2) + 
  scale_colour_manual(values = donor_colours, name = "donor")

(p1 | p2) / (p3 | p4) / (p5 | p6)
```

```{r cluster-barplot-cell-selected-merged, fig.asp = 1, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sample),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sample_colours) +
  theme_cowplot(font_size = 8)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = stage),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = stage_colours) +
  theme_cowplot(font_size = 8)

p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)

p4 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = tissue_colours) +
  theme_cowplot(font_size = 8)

p5 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = donor_colours) +
  theme_cowplot(font_size = 8)

(p1 | p2) / (p3 | p4) / (p5 | plot_spacer()) 
```

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C094_Pellicci.cells_selected.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C094_Pellicci.cells_selected.SCE.rds`](../data/SCEs/C094_Pellicci.cells_selected.SCE.rds)).
This will be used in downstream analyses, e.g., identifying cluster marker genes and refining the cell labels.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
