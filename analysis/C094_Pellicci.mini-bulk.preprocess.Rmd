---
title: "Preprocessing the Pellicci gamma-delta T-cell mini-bulk data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/rory-bowden/4536/wehi-advanced-genomics-facility
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(BiocStyle)
library(ggplot2)
library(cowplot)
library(patchwork)
library(scales)

# NOTE: Using >= 4 cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 3L))

knitr::opts_chunk$set(
  fig.path = "C094_Pellicci.mini-bulk.preprocess_files/")

source(here("code", "helper_functions.R"))
```

# Setting up the data

The count data were processed using `r Biocpkg("scPipe")` and available in a *SingleCellExperiment* object, along with their metadata.

<aside>
See [`data/SCEs/C094_Pellicci.scPipe.SCE.rds`](../data/SCEs/C094_Pellicci.scPipe.SCE.rds).
</aside>

```{r}
sce_deduped <- readRDS(here("data", "SCEs", "C094_Pellicci.scPipe.SCE.rds"))
sce_not_deduped <- readRDS(
  here("data", "SCEs", "C094_Pellicci.not_UMI_deduped.scPipe.SCE.rds"))

colnames(sce_not_deduped) <- sub(
  "\\.not_UMI_deduped",
  "",
  colnames(sce_not_deduped))
stopifnot(
  identical(rownames(sce_deduped), rownames(sce_not_deduped)),
  identical(colnames(sce_deduped), colnames(sce_not_deduped)))

# Combine UMI and read counts a single SCE.
sce <- sce_deduped
assay(sce, "UMI_counts") <- assay(sce_deduped, "counts")
assay(sce, "read_counts") <- assay(sce_not_deduped, "counts")
# NOTE: Have to reorder ERCCs
assay(altExp(sce, "ERCC"), "UMI_counts") <- assay(
  altExp(sce_deduped, "ERCC"), "counts")[rownames(altExp(sce, "ERCC")), ]
assay(altExp(sce, "ERCC"), "read_counts") <- assay(
  altExp(sce_not_deduped, "ERCC"), "counts")[rownames(altExp(sce, "ERCC")), ]

# Nullify some now-unrequired data.
assay(sce, "counts") <- NULL
assay(altExp(sce, "ERCC"), "counts") <- NULL
sce$UMI_deduped <- NULL
```

This data was processed to clean up the sample metadata, tidy the FACS index sorting data, and attach the gene metadata.

<aside>
See [`analysis/C094_Pellicci.preprocess.R`](../analysis/C094_Pellicci.preprocess.R).
</aside>

```{r}
source(here("analysis", "C094_Pellicci.preprocess.R"))
# TODO: Losing some samples (e.g., `P8 (stage 3)` in `Blood.1` - `Blood.3`)
```

**We then filter the data to only include the mini-bulk samples**.

```{r}
sce <- sce[, sce$sample_type != "Single cell"]
colData(sce) <- droplevels(colData(sce))

# Only retain genes with non-zero counts in at least 1 cell.
sce <- sce[rowSums(assay(sce, "read_counts")) > 0, ]
```

## Incorporating cell-based annotations

```{r}
# Some useful colours
plate_number_colours <- setNames(
  unique(sce$colours$plate_number_colours),
  unique(names(sce$colours$plate_number_colours)))[levels(sce$plate_number)]
sample_type_colours <- setNames(
  unique(sce$colours$sample_type_colours),
  unique(names(sce$colours$sample_type_colours)))[levels(sce$sample_type)]
sample_gate_colours <- setNames(
  unique(sce$colours$sample_gate_colours),
  unique(names(sce$colours$sample_gate_colours)))[levels(sce$sample_gate)]
stage_colours <- setNames(
  unique(sce$colours$stage_colours),
  unique(names(sce$colours$stage_colours)))[levels(sce$stage)]
sequencing_run_colours <- setNames(
  unique(sce$colours$sequencing_run_colours),
  unique(names(sce$colours$sequencing_run_colours)))[levels(sce$sequencing_run)]
tissue_colours <- setNames(
  unique(sce$colours$tissue_colours),
  unique(names(sce$colours$tissue_colours)))[levels(sce$tissue)]
donor_colours <- setNames(
  unique(sce$colours$donor_colours),
  unique(names(sce$colours$donor_colours)))[levels(sce$donor)]

sample_colours <- setNames(
  scater:::.get_palette("tableau20")[seq_len(nlevels(sce$sample))],
  levels(sce$sample))
sce$colours$sample_colours <- sample_colours[sce$sample]
```

Cell-based annotations are included in the *colData* of the *SingleCellExperiment*.
Figure \@ref(fig:coldata) is a visual summary of the cell-based metadata.

<aside>
The 'SKW-3' sample is a control cell line, originally thought to originate from the peripheral blood of a 61 year old male patient with T cell chronic lymphocytic leukemia. (although [this is known to be problematic](https://web.expasy.org/cellosaurus/CVCL_2197)).
</aside>

```{r coldata, fig.cap = "Breakdown of experiment by plate."}
p1 <- ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = donor),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = donor_colours)
p2 <- ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = sample),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = sample_colours) +
  guides(fill = guide_legend(ncol = 2))
p3 <- ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = sample_gate),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = sample_gate_colours)
p4 <-  ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = sample_type),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = sample_type_colours)
p5 <-  ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = sequencing_run),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = sequencing_run_colours)
p6 <-  ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = stage),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = stage_colours)
p7 <-  ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = tissue),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = tissue_colours)
p8 <- ggcells(sce) + 
  geom_bar(aes(x = plate_number, fill = plate_number)) +
  coord_flip() +
  ylab("Number of mini-bulk samples") +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = plate_number_colours)

p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + plot_layout(ncol = 3)
```

Figure \@ref(fig:blood-stage) highlights that the `Blood.1`, `Blood.2`, and `Blood.3` samples collected on plate `LCE515` were from FACS gate `P5` (corresponding to a mixture of stages 1-3) whereas all subsequent `Blood` samples were from FACS gate `P8` (correspond to stage 3).

```{r blood-stage, fig.cap = "Breakdown of experiment by donor.", fig.asp = 1 / 4}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = donor, fill = sample_gate), 
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  facet_grid(~tissue) +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = sample_gate_colours)
p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = donor, fill = stage), 
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  facet_grid(~tissue) +
  theme_cowplot(font_size = 6) +
  scale_fill_manual(values = stage_colours)
p3 <- ggcells(sce) + 
  geom_bar(aes(x = donor, fill = plate_number)) +
  coord_flip() +
  ylab("Number of mini-bulk samples") +
  theme_cowplot(font_size = 6) +
  facet_grid(~tissue) +
  scale_fill_manual(values = plate_number_colours)

p1 + p2 + p3 + plot_layout(ncol = 3)
```

Figure \@ref(fig:plate-map) shows the design of each plate.

```{r plate-map, fig.cap = "Plate maps.", fig.asp = 0.5}
# TODO: Fix legend
p <- lapply(levels(sce$plate_number), function(p) {
  z <- sce[, sce$plate_number == p]
  plotPlatePosition(
    z,
    as.character(z$well_position),
    point_size = 2,
    point_alpha = 1,
    theme_size = 8,
    colour_by = "donor",
    shape_by = "tissue") +
    scale_colour_manual(values = donor_colours, name = "donor") +
    ggtitle(p) +
    theme(
      legend.text = element_text(size = 6),
      legend.title = element_text(size = 6)) +
    guides(
      colour = guide_legend(override.aes = list(size = 4, alpha = 1)),
      shape = guide_legend(override.aes = list(size = 4, alpha = 1)))
})

wrap_plots(p, ncol = 2)
```

## Incorporating gene-based annotation

I used the `r BiocStyle::Biocpkg("Homo.sapiens")` package and the `EnsDb.Hsapiens.v98` resource, which respectively cover the NCBI/RefSeq and Ensembl databases, to obtain gene-based annotations, such as the chromosome and gene symbol.

Having quantified gene expression against the GENCODE gene annotation, we have Ensembl-style identifiers for the genes. 
These identifiers are used as they are unambiguous and highly stable. 
However, they are difficult to interpret compared to the gene symbols which are more commonly used in the literature.
Henceforth, we will use gene symbols (where available) to refer to genes in our analysis and otherwise use the Ensembl-style gene identifiers^[Some care is taken to account for missing and duplicate gene symbols; missing symbols are replaced with the Ensembl identifier and duplicated symbols are concatenated with the (unique) Ensembl identifiers.].

We also construct some useful gene sets: mitochondrial genes, ribosomal protein genes, sex chromosome genes, and pseudogenes.

```{r}
# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$gene_symbol)
ribo_set <- intersect(ribo_set, rownames(sce))
sex_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME %in% c("X", "Y"))]
pseudogene_set <- rownames(sce)[
  any(grepl("pseudogene", rowData(sce)$ENSEMBL.GENEBIOTYPE))]
```

# Read mapping metrics

## Motivation

We aimed to sequence **TODO** HOW MANY? million reads/sample and hoped that the majority of these reads would be exonic.

## Analysis

```{r}
library(scPipe)
sce$nreads <- apply(QC_metrics(sce_deduped)[colnames(sce), ], 1, sum)
```

Figure \@ref(fig:nreads) shows that we generated a median of `r number(median(sce$nreads) / 1e6, accuracy = 0.1)` million reads per sample with a median `r percent(median(sce$mapped_to_exon / sce$nreads))` of these exonic.

```{r nreads, fig.cap = "Number of reads generated per sample and the proportion that are exonic and intronic. The dashed horizional line denotes the median across all samples."}
p1 <- plotColData(
  sce, "nreads", 
  x = "sample", 
  other_fields = "plate_number", 
  colour_by = "sample") +
  scale_y_log10() +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = sample_colours, name = "sample") +
  xlab("") +
  geom_hline(yintercept = median(sce$nreads), lty = 2) +
  annotation_logticks(
    sides = "l",
    short = unit(0.06, "cm"),
    mid = unit(0.12, "cm"),
    long = unit(0.18, "cm"))
p2 <- plotColData(
  sce, 
  I(sce$mapped_to_exon / sce$nreads), 
  x = "sample", 
  other_fields = "plate_number",
  colour_by = "sample") + 
  ylim(0, 1) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = sample_colours, name = "sample") +
  xlab("") +
  ylab("Prop exonic") +
  geom_hline(yintercept = median(sce$mapped_to_exon / sce$nreads), lty = 2)
p3 <- plotColData(
  sce, 
  I(sce$mapped_to_intron / sce$nreads), 
  x = "sample", 
  other_fields = "plate_number",
  colour_by = "sample") + 
  ylim(0, 1) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = sample_colours, name = "sample") +
  xlab("") +
  ylab("Prop intronic") +
  geom_hline(yintercept = median(sce$mapped_to_intron / sce$nreads), lty = 2)

(p1 | (p2 / p3)) + plot_layout(guides = "collect", widths = c(2, 1))  
```

We observe that the `Blood.1`, `Blood.2`, and `Blood.3` have notably fewer reads than other samples
**These 3 samples are all on plate `LCE515` and are being resequenced to obtain more data.**

## Summary

**TODO** Re-write once we know what the target was. Also, update according to additional analysis presented in meeting with Dan (2021-07-15).

We largely achieved our aim of sequencing **TODO** How many million reads/sample and with the majority of reads being exonic.
**Henceforth, we only use the exonic reads.**
Although the intronic reads are potentially useful, to do so would require substantial changes to the data analysis workflow and additional analysis.

We now remove the control samples.

```{r}
sce <- sce[, sce$tissue != "SKW3"]
colData(sce) <- droplevels(colData(sce))
```

# Have we sequenced enough?

## Motivation

SCORE's mini-bulk protocol is still being finalised and some technical questions remain.
In particular, we want to know if we have sequenced enough to answer the biological questions of interest.

One way of estimating if we have sequenced enough uses a metric called 'sequencing saturation'.
10x Genomics have some useful information about sequencing saturation available [here](https://kb.10xgenomics.com/hc/en-us/articles/115005062366-What-is-sequencing-saturation-).
In particular,

>  Sequencing saturation is a measure of the fraction of library complexity that was sequenced in a given experiment. The inverse of the sequencing saturation can be interpreted as the number of additional reads it would take to detect a new transcript. ... Sequencing saturation is dependent on the library complexity and sequencing depth. Different cell types will have different amounts of RNA and thus will differ in the total number of different transcripts in the final library (also known as library complexity). ... As sequencing depth increases, more genes are detected, but this reaches saturation at different sequencing depths depending on cell type. ... Sequencing depth also affects sequencing saturation; generally, the more sequencing reads, the more additional unique transcripts you can detect. However, this is limited by the library complexity.

> This naturally leads to the question of ['how much sequencing saturation should I aim for?'](https://kb.10xgenomics.com/hc/en-us/articles/115002474263-How-much-sequencing-saturation-should-I-aim-for-), which very much depends on the goals of the experiment.

For this experiment, where we wish to assess differential expression between experimental groups, we will likely want quite high sequencing saturation.

## Analysis

To begin, we simply examine the number of reads sequenced/sample.

```{r}
reads_ls <- log10(colSums(assay(sce, "read_counts")))
```

Figure \@ref(fig:read-library-size) plots the distribution of the number of reads mapped to exons in each sample^[I.e. the 'library size' when using read counts].

```{r read-library-size, fig.cap = "Distribution of the number of reads mapped to exons in each sample."}
plot(
  density(reads_ls),
  xlab = expression(log[10](n[reads])),
  ylab = "density",
  xlim = range(reads_ls),
  main = "")
```

We estimate the sequencing saturation using [10x Genomics' formula](https://kb.10xgenomics.com/hc/en-us/articles/115003646912-How-is-sequencing-saturation-calculated-), 

$$
1 - (n_{deduped reads} / n_{reads})
$$
where:

- $n_{deduped reads}$ = Number of unique (valid cell-barcode, valid UMI, gene)-combinations among confidently mapped reads
- $n_{reads}$ = Total number of confidently mapped, valid cell-barcode, valid UMI reads

```{r}
saturation <- 1 - 
  (colSums(assay(sce, "UMI_counts")) / colSums(assay(sce, "read_counts")))
```

Figure \@ref(fig:saturation) shows that almost all samples are sequenced to near-total saturation.

```{r saturation, fig.cap = "Distribution of the sequencing saturation."}
par(mfrow = c(1, 1))
plot(
  density(
    saturation,
    from = 0,
    to = 1),
  xlab = "saturation",
  ylab = "density",
  xlim = c(0, 1),
  main = "Sequencing saturation")
```

## Summary

These results show that the libraries are sequenced to near-saturation.

One way to think of sequencing saturation is [provided by 10x Genomics](https://kb.10xgenomics.com/hc/en-us/articles/115002474263-How-much-sequencing-saturation-should-I-aim-for-):

> The inverse of the sequencing saturation can be interpreted as roughly the number of new transcripts you expect to find with one new read. If sequencing saturation is at 50%, it means that every 2 new reads will result in 1 new UMI count (unique transcript) detected. In contrast, 90% sequencing saturation means that 10 new reads are necessary to obtain one new UMI count. If the sequencing saturation is high, additional sequencing would not recover much new information for the library.

**At this stage, it is not necessary to perform additional sequencing of the library (with the exception of the `Blood.1`, `Blood.2`, and `Blood.3` samples).**

# UMI counts vs. read counts

## Motivation

A unique feature of SCORE's 'mini-bulk' RNA-sequencing protocol is the incorporation of unique molecular identifiers (UMIs) into the library preparation; an ordinary bulk RNA-seq protocol does not incorporate UMIs.

UMIs are commonly used in single-cell RNA-sequencing protocols, such as the CEL-Seq2 protocol from which the mini-bulk protocol is adapted.
UMIs are molecular tags that are used to detect and quantify unique mRNA transcripts.
In this method, mRNA libraries are generated by fragmentation and reverse-transcribed to cDNA.
Oligo(dT) primers with specific sequencing linkers are added to the cDNA.
Another sequencing linker with a 6 bp random label and an index sequence is added to the 5' end of the template, which is amplified and sequenced.

<aside>
This explanation is adapted from [https://sapac.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html](https://sapac.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html).
</aside>

The UMI count is always less than or equal to the read count and a UMI count of zero also implies a read count of zero.

Pros of using UMIs:

- Can sequence unique mRNA transcripts
- Can detect transcripts occurring at low frequencies
- Transcripts can be quantified based on sequencing reads specific to each barcode

Cons of using UMIs:

- SCORE's mini-bulk protocol uses a $k=6$ bp UMI^[The choice of a 6 bp UMI in the mini-bulk protocol is because it is adapted from SCORE's CEL-Seq2 single-cell RNA-sequencing protocol. With scRNA-seq data it is very rare to observe more than $4^k = 4^6 = 4096$ unique molecules for any one gene.] and so (theoretically) the maximum UMI count for each gene is $4^6 = 4096$.
- There is therefore a risk that highly expressed genes may have their expression measurements artificially truncated, particularly if the sample is deeply sequenced.

To investigate whether expression measurements are being 'truncated' in this dataset, and decide whether to use the UMI counts or the read counts, we generated and now analyse two count matrices:

1. UMI counts (i.e. deduplicating UMI counts)
2. Read counts (i.e. not deduplicating UMI counts, equivalent to ignoring the UMIs)

## Analysis

```{r}
n <- apply(assay(sce, "read_counts"), 1, function(x) sum(x > 4 ^ 6))
g <- names(n[n > 0])
```

Figure \@ref(fig:read-distribution) plots the distribution of the logarithm of the read counts.
From this we see that the vast majority of read counts are small. 
In fact:

- `r percent(sum(as.vector(assay(sce, "read_counts")) == 0) / prod(dim(sce)), accuracy = 0.1)` of read counts are 0
- 95% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.95), big.mark = ",")` 
- 99% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.99), big.mark = ",")` 
- 99.9% of the read counts are no greater than `r number(quantile(as.vector(assay(sce, "read_counts")), 0.999), big.mark = ",")`

```{r read-distribution, fig.cap = "Distribution of the logarithm of the read counts as density plot (left) and empirical cumulative distribution function (right). A count of 1 is added to each UMI count to avoid taking the logarithm of zero. The orange vertical line denotes $4^6 = 4096$.", fig.asp = 1 / 2}
x <- as.vector(assay(sce, "read_counts")) + 1L
par(mfrow = c(1, 2), cex = 0.5)
plot(
  density(log2(x), from = min(log2(x)), to = max(log2(x))),
  xlab = expression(log[2](reads + 1)),
  main = "",
  ylab = "density")
abline(v = log2(4 ^ 6), col = "orange")
plot(
  ecdf(log2(x)), 
  xlim = range(log2(x)),
  main = "",
  xlab = expression(log[2](reads + 1)),
  ylab = "cumulative density")
abline(v = log2(4 ^ 6), col = "orange")
```

Only `r percent(sum(as.vector(assay(sce, "read_counts")) > 4^6) / prod(dim(sce)), accuracy = 0.001)` of read counts exceed the $4^6 = 4096$ threshold.
However there are `r number(length(g), big.mark = ",")` genes for which at least one sample exceeds the $4^6=4096$ threshold; these genes are shown in the table below.
If we were to use the UMI counts, the genes in this list may have their expression measurements artificially truncated in those samples where the number of copies of the transcript exceed the $4^6=4096$ threshold.

This table shows that many of these genes are mitochondrial and ribosomal protein genes.

```{r}
read_e <- as.matrix(assay(sce, "read_counts")[g, ])
umi_e <- as.matrix(assay(sce, "UMI_counts")[g, ])
high_count_tbl <- tibble::tibble(
  gene = g,
  read_median_count = matrixStats::rowMedians(read_e),
  read_exceed_sum = matrixStats::rowSums2(read_e > 4 ^ 6),
  read_exceed_percent = read_exceed_sum / ncol(sce),
  umi_median_count = matrixStats::rowMedians(umi_e),
  umi_exceed_sum = matrixStats::rowSums2(umi_e > 4 ^ 6),
  umi_exceed_percent = umi_exceed_sum / ncol(sce)) %>%
  dplyr::arrange(desc(read_exceed_sum))
sketch <- htmltools::withTags(table(
  class = "display",
  thead(
    tr(
      th(rowspan = 2, "gene"),
      th(colspan = 3, "reads"),
      th(colspan = 3, "UMIs")
    ),
    tr(
      lapply(rep(c("median count", "N > 4096", "% > 4096"), 2), th)
    )
  )
))
DT::datatable(
  high_count_tbl, 
  caption = "Genes for which any sample has a read count exceeding the 4096 threshold and summaries of the corresponding read and UMI counts, namely: the median count ('median count'); the number of samples for which the counts exceed the threshold ('N > 4096'); and the percentage of samples for which the counts exceed the threshold ('% > 4096').",
  container = sketch,
  rownames = FALSE) %>%
  DT::formatPercentage(
    columns = c("read_exceed_percent", "umi_exceed_percent"),
    digits = 1) %>%
  DT::formatRound(
    columns = c("read_median_count", "umi_median_count"),
    digits = 0)
```

We can investigate this list more formally using a statistical test for over-representation of gene ontology (GO) terms in this gene set.
This is done using the `goana()` function from the `r BiocStyle::Biocpkg("limma")` package.
These results are shown in the table below and confirm that these genes are enriched for GO terms related to ribosomal and mitochondrial processes.
This is something we frequently see with the mini-bulk protocol and the CEL-Seq protocol from which it is derived.

```{r}
library(limma)
go <- goana(unlist(rowData(sce[g, ])$NCBI.ENTREZID), species = "Hs")
tg <- topGO(go, number = Inf)
DT::datatable(
  tg[tg$P.DE < 0.05, ],
  caption = "Most significant GO terms for genes with read counts that exceed the 4096 threshold. Report columns are the ontology that the GO term belongs to ('Ont'); the number of genes in the GO term ('N'); the number of genes in the DE set ('DE'); and the p-value for over-representation of the GO term in the set ('P.DE'). The p-values returned are unadjusted for multiple testing because GO terms are often overlapping, so standard methods of p-value adjustment may be very conservative. This means that only very small p-values should be used for published results.") %>%
  DT::formatRound(columns = "P.DE", digits = 9)
```

Figure \@ref(fig:scatterplot-and-ma-plot) plots the relationship between UMI counts and read counts for all genes and samples.
There are a few notable points about this figure:

1. The UMI counts and read counts are very strongly associated.
2. The log-fold change between the read counts and the UMI counts can be large, indicating the UMI counts are likely removing substantial PCR amplification noise.
3. The log-fold changes between the read counts and the UMI counts are larger on average for more highly expressed genes. The variation in the log-fold change is larger for the lowly expressed genes.
4. The hemoglobin genes stand out. These genes are extremely highly expressed, meaning that they likely saturate the 6 bp UMIs and which leads to the strange relationship between the UMI counts and the read counts for these genes.

```{r scatterplot-and-ma-plot, fig.cap = "Scatterplot of the logarithm of the UMI and read counts (top) and logCPM of the UMI and read counts (bottom) for all genes and samples (left) and mean-difference plot of the same data (right). The correlation in the scatterplot is reported below the x-axis label. Genes that are ribosomal protein genes subunits are highlighted in orange and mitochondrial genes in blue. The red line is a trend fitted to the mean-differences.", fig.asp = 1}
x <- log2(as.vector(assay(sce, "UMI_counts")) + 1)
y <- log2(as.vector(assay(sce, "read_counts")) + 1)
m <- (x + y) / 2
d <- y - x
g <- rep(rownames(sce), ncol(sce))
# NOTE: Only showing unique points for plotting speed.
i <- !duplicated(paste0(x, ".", y))
X <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)
Y <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
M <- (X + Y) / 2
D <- y - x
G <- g
# NOTE: Only showing unique points for plotting speed.
I <- !duplicated(paste0(x, ".", y))
par(mfrow = c(2, 2))
plotWithHighlights(
  x = x[i],
  y = y[i],
  status = ifelse(g[i] %in% ribo_set, 1, ifelse(g[i] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  sub = paste0("r = ", number(cor(x, y), accuracy = 0.001)),
  xlab = expression(log[2](UMIs + 1)),
  ylab = expression(log[2](reads + 1)))
abline(a = 0, b = 1, lty = 2, col = "grey")
plotWithHighlights(
  x = m[i] / 2,
  y = d[i],
  pch = ".",
  status = ifelse(g[i] %in% ribo_set, 1, ifelse(g[i] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  xlab = "Average log-(count+1)",
  ylab = "logFC (reads vs. UMIs)",
  ylim = c(-max(abs(c(d, D))), max(abs(c(d, D)))))
abline(h = 0, lty = 2, col = "grey")
l <- lowess(m, d, f = 0.3)
lines(l, col = "red", lwd = 2)
plotWithHighlights(
  x = X[I],
  y = Y[I],
  status = ifelse(G[I] %in% ribo_set, 1, ifelse(G[I] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  sub = paste0(
    "r = ", 
    number(cor(as.vector(X), as.vector(Y)), accuracy = 0.001)),
  xlab = expression(logCPM(UMIs)),
  ylab = expression(logCPM(reads)))
abline(a = 0, b = 1, lty = 2, col = "grey")
plotWithHighlights(
  x = M[I],
  y = D[i],
  status = ifelse(G[I] %in% ribo_set, 1, ifelse(G[I] %in% mito_set, -1, 0)),
  legend = FALSE,
  bg.pch = ".",
  hl.pch = ".",
  hl.col = c("orange", "dodgerBlue"),
  hl.cex = 3,
  xlab = "Average logCPM",
  ylab = "logFC (reads vs. UMIs)",
  ylim = c(-max(abs(c(d, D))), max(abs(c(d, D)))))
abline(h = 0, lty = 2, col = "grey")
l <- lowess(M, D, f = 0.3)
lines(l, col = "red", lwd = 2)
```

Rather than looking at all samples and all genes at once, can also examine the relationship between UMI counts and read counts within a single sample across genes (Figure \@ref(fig:within-sample-cors)) and within a single gene across samples (Figure \@ref(fig:within-gene-cors)).

```{r}
X <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)
Y <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
cor_j <- diag(cor(X, Y))
# NOTE: Splitting up the cor() computations is a hack to improve speed whilst 
#       keeping memory usage somewhat under control.
b <- 1000
s <- seq(1, by = b, to = nrow(sce))
e <- pmin(s + b - 1, nrow(sce))
cor_i <- unlist(
  Map(
    f = function(ss, ee ) diag(cor(t(X[ss:ee, ]), t(Y[ss:ee, ]))),
    ss = s,
    ee = e))
```

These figures show that the UMI counts and read counts are highly correlated across both samples (median = `r number(median(cor_j, na.rm = TRUE), accuracy = 0.001)`, median absolute deviation = `r number(mad(cor_j, na.rm = TRUE), accuracy = 0.001)`) and genes (median = `r number(median(cor_i, na.rm = TRUE), accuracy = 0.001)`, median absolute deviation = `r number(mad(cor_i, na.rm = TRUE), accuracy = 0.001)`).

<aside>
The genes with the lowest correlations include the aforementioned highly-expressed hemoglobin subunits.
</aside>

```{r within-sample-cors, fig.cap = "Association between UMI counts and read counts for each gene within each sample. The first 8 panels are scatter plots of the UMI counts and read counts for each gene for the samples with the 3 lowest correlations, 2 middlemost correlations, and 3 highest correlations. The correlation in the scatterplot is reported below each panel. Genes that are ribosomal protein genes subunits are highlighted in orange and mitochondrial genes in blue. The final panel is the distribution of these correlations across all samples.", fig.asp = 1}
par(mfrow = c(3, 3), cex = 0.5)
jj <- names(sort(cor_j)[c(1:3, 60:61, 119:121)])
for (j in jj) {
  g <- rownames(sce)
  plot(
    x = X[, j],
    y = Y[, j],
    pch = ".",
    cex = ifelse(g %in% c(ribo_set, mito_set), 5, 1),
    col = ifelse(
      g %in% ribo_set, "orange",
      ifelse(g %in% mito_set, "dodgerBlue", "black")),
    sub = paste0("r = ", number(cor_j[j], accuracy = 0.001)),
    xlab = "logCPM(UMIs)",
    ylab = "logCPM(reads)",
    main = j,
    xlim = range(x),
    ylim = range(y))
  abline(a = 0, b = 1, col = "grey", lty = 2)
}
plot(
  density(cor_j, na.rm = TRUE, from = -1, to = 1),
  main = "All samples", 
  xlab = expression(r[p]))
```

```{r within-gene-cors, fig.cap = "Association between UMI counts and read counts for each sample within each gene. The first 8 panels are scatter plots of the UMI counts and read counts for each sample for the genes with the 3 lowest correlations, 2 middlemost correlations, and 3 highest correlations. The correlation in the scatterplot is reported below each panel. Genes that are ribosomal protein genes subunits are highlighted in orange and mitochondrial genes in blue. The final panel is the distribution of these correlations across all genes.", fig.asp = 1}
par(mfrow = c(3, 3), cex = 0.5)
# NOTE: There are some NA correlations, so this changes ii.
ii <- names(sort(cor_i)[c(1:3, 16506:16507, 33011:33013)])
for (i in ii) {
  g <- i
  plot(
    x = X[i, ],
    y = Y[i, ],
    pch = 16,
    col = ifelse(
      g %in% ribo_set, "orange",
      ifelse(g %in% mito_set, "dodgerBlue", "black")),
    sub = paste0("r = ", number(cor_i[i], accuracy = 0.001)),
    xlab = "logCPM(UMIs)",
    ylab = "logCPM(reads)",
    main = i,
    xlim = range(X),
    ylim = range(Y))
  abline(a = 0, b = 1, col = "grey", lty = 2)
}
plot(
  density(cor_i, na.rm = TRUE, from = -1, to = 1),
  main = "All genes", 
  xlab = expression(r[p]))
```

## Summary

The ultimate aim of this analysis is to perform a differential expression (DE) analysis. 
On the one hand, a DE analysis is more powerful when there are more counts available, which is where the read counts are favoured.
On the other hand, a DE analysis may be biased if these counts arise through PCR duplicates, which is where the deduplicated UMI counts are favoured.
The choice between using the read counts or the UMI counts in the DE analysis is therefore a trade-off between these two choices.

**For now, we defer our choice of read counts vs. UMI counts, but the remainder of this preprocessing report uses (exonic) read counts**.

# Quality control of cells

## Defining the quality control metrics

Low-quality cells need to be removed to ensure that technical effects do not distort downstream analysis results.
We use several quality control (QC) metrics to measure the quality of the cells:

- `sum`: This measures the library size of the samples, which is the total sum of counts across genes. We want samples to have high library sizes as this means more RNA has been successfully captured during library preparation. 
- `detected`: This is the number of expressed features^[The number of expressed genes refers to the number of genes which have non-zero counts (ie. they have been identified in the cell at least once)] in each cell. Cells with few expressed features are likely to be of poor quality, as the diverse transcript population has not been successful captured. 
- `altexps_ERCC_detected`: This measures the proportion of reads which are mapped to spike-in transcripts relative to the library size of each cell. High proportions are indicative of poor-quality cells, where endogenous RNA has been lost during processing (e.g., due to cell lysis or RNA degradation). 
The same amount of spike-in RNA to each cell, so an enrichment in spike-in counts is symptomatic of loss of endogenous RNA.
- `subsets_Mito_percent`: This measures the proportion of reads which are mapped to mitochondrial RNA. If there is a higher than expected proportion of mitochondrial RNA this is often symptomatic of a cell which is under stress and is therefore of low quality and will not be used for the analysis. 
- `subsets_Ribo_percent`: This measures the proportion of UMIs which are mapped to ribosomal protein genes. If there is a higher than expected proportion of ribosomal protein gene expression this is often symptomatic of a cell which is of compromised quality and we may want to exclude it from the analysis. 

For CEL-Seq2 data, we typically observe library sizes that are in the tens of thousands^[This is consistent with the use of UMI counts rather than read counts, as each transcript molecule can only produce one UMI count but can yield many reads after fragmentation.] and several thousand expressed genes per cell.

```{r, results = "hide"}
is_mito <- rownames(sce) %in% mito_set
summary(is_mito)
is_ribo <- rownames(sce) %in% ribo_set
summary(is_ribo)
sce <- addPerCellQC(
  sce, 
  subsets = list(Mito = which(is_mito), Ribo = which(is_ribo)),
  use.altexps = "ERCC",
  assay.type = "read_counts")
```

## Visualizing the QC metrics

Figure \@ref(fig:qcplot) compares the QC metrics of the single-cell samples across the different `sample` (combination of `tissue` and `donor`) and Figure \@ref(fig:qcplot-by-plate-number) further stratifies by `plate_number`.
The number of UMIs, number of gene detected, and percentage of UMIs that are mapped to ERCC spike-ins are all higher in the 'experimental' samples than in the 'control' samples
This likely reflects that the 'experimental' cells, which are γδ T cells, have a 'smaller' transcriptome than the 'control' cells (rather than this result being due to technical factors, although we cannot rule this out entirely).
Together, these figures show that the vast majority of single-cell samples are good-quality^[Bearing in mind that the 'experimental' cells, which are γδ T cells, have a 'smaller' transcriptome than the 'control' cells.]:

- The median library size is around `r number(median(sce$sum), accuracy = 100, big.mark = ",")`.
- The median number of genes detected is around `r number(median(sce$detected), accuracy = 100, big.mark = ",")`.
- The median percentage of reads that are mapped to mitochondrial RNA is around  `r percent(median(sce$subsets_Mito_percent), scale = 1)`.
- The median percentage of reads that are mapped to ribosomal protein genes is around  `r percent(median(sce$subsets_Ribo_percent), scale = 1)`.
- The median percentage of reads that are mapped to ERCC spike-ins is around  `r percent(median(sce$altexps_ERCC_percent), scale = 1)`.

Figure \@ref(fig:qcplot) also highlights that the `Blood.1`, `Blood.2`, and `Blood.3` samples on plate `LCE515` have fewer reads and genes detected than other samples, but that the that QC metrics are otherwise generally consistent across samples (and plates).

```{r qcplot, fig.cap = "Distributions of various QC metrics for all samples in the dataset.", fig.asp = 1}
p1 <- plotColData(
  sce,
  "sum",
  x = "donor",
  other_fields = "tissue",
  point_size = 0.5,
  colour_by = "donor") +
  scale_y_log10() +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm")) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  xlab("") +
  facet_grid(~tissue) +
  guides(colour = guide_legend(override.aes = list(size = 4, alpha = 1)))
p2 <- plotColData(
  sce,
  "detected",
  x = "donor",
  other_fields = "tissue",
  point_size = 0.5,
  colour_by = "donor") +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  xlab("") +
  facet_grid(~tissue) +
  guides(colour = guide_legend(override.aes = list(size = 4, alpha = 1)))
p3 <- plotColData(
  sce,
  "subsets_Mito_percent",
  x = "donor",
  other_fields = "tissue",
  point_size = 0.5,
  colour_by = "donor") +
  ylim(0, NA) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  xlab("") +
  facet_grid(~tissue) +
  guides(colour = guide_legend(override.aes = list(size = 4, alpha = 1)))
p4 <- plotColData(
  sce,
  "subsets_Ribo_percent",
  x = "donor",
  other_fields = "tissue",
  point_size = 0.5,
  colour_by = "donor") +
  ylim(0, NA) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  xlab("") +
  facet_grid(~tissue) +
  guides(colour = guide_legend(override.aes = list(size = 4, alpha = 1)))
p5 <- plotColData(
  sce,
  "altexps_ERCC_percent",
  x = "donor",
  other_fields = "tissue",
  point_size = 0.5,
  colour_by = "donor") +
  ylim(0, NA) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  xlab("") +
  facet_grid(~tissue) +
  guides(colour = guide_legend(override.aes = list(size = 4, alpha = 1)))
p1 + p2 + p3 + p4 + p5 + 
  plot_layout(ncol = 2, guides = "collect")
```

## Identifying outliers by each metric

Outliers are defined based on the median absolute deviation (MADs) from the median value of each metric across all cells. 
We remove small and large outliers for the library size and the number of expressed features, and large outliers for the spike-in proportions and mitochondrial gene expression proportions.
Removal of low-quality cells is then performed by combining the filters for all of the metrics.

Due to the differences in the QC metrics by `sample`, we will compute the separate outlier thresholds for each `sample`.

```{r}
sce$batch <- sce$sample
libsize_drop <- isOutlier(
  metric = sce$sum, 
  nmads = 3,
  type = "lower", 
  log = TRUE,
  batch = sce$batch)
feature_drop <- isOutlier(
  metric = sce$detected,
  nmads = 3, 
  type = "lower", 
  log = TRUE,
  batch = sce$batch)
spike_drop <- isOutlier(
  metric = sce$altexps_ERCC_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$batch)
mito_drop <- isOutlier(
  metric = sce$subsets_Mito_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$batch)
ribo_drop <- isOutlier(
  metric = sce$subsets_Ribo_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$batch)
```

The following table summarises the QC cutoffs:

```{r}
libsize_drop_df <- data.frame(
  batch = colnames(attributes(libsize_drop)$thresholds),
  cutoff = attributes(libsize_drop)$thresholds["lower", ])
feature_drop_df <- data.frame(
  batch = colnames(attributes(feature_drop)$thresholds),
  cutoff = attributes(feature_drop)$thresholds["lower", ])
spike_drop_df <- data.frame(
  batch = colnames(attributes(spike_drop)$thresholds),
  cutoff = attributes(spike_drop)$thresholds["higher", ])
mito_drop_df <- data.frame(
  batch = colnames(attributes(mito_drop)$thresholds),
  cutoff = attributes(mito_drop)$thresholds["higher", ])
ribo_drop_df <- data.frame(
  batch = colnames(attributes(ribo_drop)$thresholds),
  cutoff = attributes(ribo_drop)$thresholds["higher", ])
qc_cutoffs_df <- Reduce(
  function(x, y) inner_join(x, y, by = "batch"),
  list(
    libsize_drop_df,
    feature_drop_df, 
    spike_drop_df, 
    mito_drop_df, 
    ribo_drop_df))
qc_cutoffs_df$batch <- factor(qc_cutoffs_df$batch, levels(sce$batch))
colnames(qc_cutoffs_df) <- c(
  "batch", "total counts", "total features", "%ERCC", "%mito", "%ribo")
qc_cutoffs_df %>%
  arrange(batch) %>%
  knitr::kable(caption = "QC cutoffs", digits = 1)
```

**We would typically remove outliers (e.g., small outliers for the library size and the number of expressed features) at this stage.**
However, we opt to retain all samples for the time being.
The following table highlights samples that would typically exclude as outliers by this criteria:

```{r}
keep <- !(libsize_drop | libsize_drop | mito_drop)
x <- cbind(
  data.frame(sample = colnames(sce), keep = keep),
  colData(sce)[, c("plate_number", "sample", "sum", "detected")])
row.names(x) <- NULL
DT::datatable(
  x[order(keep), ],
  caption = "Quality control metrics including library size (`sum`) and number of genes detected (`keep`) for each replicate. Each replicate is annotated by whether it would be kept or excluded by the typical quality control procedures (`keep`).",
  rownames = FALSE)
```

## Summary

We have opted not to exclude any replicates at this stage.
However, we have identified some replicates with unusually small library sizes and number of genes detected compared to the other samples.
We will keep an eye on these replicates and may later remove some of these.

# Examining gene-level metrics

## Inspecting the most highly expressed genes

Figure \@ref(fig:topgenes) shows the most highly expressed genes across the cell population in the combined data set.
Some of them are mitochondrial genes, matching what we've already seen in the QC metrics, and ribosomal protein genes, which commonly are amongst the most highly expressed genes in scRNA-seq data.

```{r topgenes, fig.asp = 1, fig.cap = "Percentage of total counts assigned to the top 50 most highly-abundant features in the combined data set. For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle represents the average across all cells."}
plotHighestExprs(sce, n = 50, exprs_values = "read_counts")
```

Figure \@ref(fig:topgenes-filtered) shows the most highly expressed endogenous genes after excluding the mitochondrial and ribosomal protein genes.

```{r topgenes-filtered, fig.asp = 1, fig.cap = "Percentage of total counts assigned to the top 50 most highly-abundant features in the combined data set. For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle represents the average across all cells. Bars are coloured by the total number of expressed features in each cell, while circles are coloured according to whether the feature is labelled as a control feature."}
plotHighestExprs(
  sce,
  drop_features = rownames(sce) %in% c(mito_set, ribo_set),
  n = 50,
  exprs_values = "read_counts")
```

## Sex check

### Using *XIST* expression

Figure \@ref(fig:xist-expression) visualises the expression of *XIST*, a female-specific gene.
This can be used to confirm the reported sex of the sample and to detect sample mix-ups.

**TODO** Re-write: Results are clear for `Thymus` but less so for `Blood` (SKW3 has similar to male `Thymus` samples (data not shown)).

Figure \@ref(fig:xist-expression) shows that female samples have much higher average expression of *XIST* than male samples, as we would expect.

**TODO** Re-write

There is one replicate, `Del.1282.2`, that has is nominally male but has $logCPM(UMI_{counts})$ for *XIST* that is comparable to the female samples.
However, we have already seen that this replicate has an unusually small library size (by reads and UMIs) and number of genes detected compared to the other samples, so it already suspect.

```{r xist-expression, fig.cap = "Expression of *XIST* by donor and tissue on a 'raw counts' and 'logCPM' scale using the read or UMI counts."}
assay(sce, "logCPM_reads") <- edgeR::cpm(assay(sce, "read_counts"), log = TRUE)
assay(sce, "logCPM_umis") <- edgeR::cpm(assay(sce, "UMI_counts"), log = TRUE)

p1 <- plotExpression(
  sce,
  "XIST",
  x = "donor",
  exprs_values = "read_counts",
  colour_by = "donor",
  other_fields = "tissue") + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  guides(fill = FALSE) +
  ylab("Read counts")  +
  ylim(0, NA) +
  facet_grid(~tissue) +
  theme(axis.text.x = element_blank()) + 
  xlab("")
p2 <- plotExpression(
  sce,
  "XIST",
  x = "donor",
  exprs_values = "logCPM_reads",
  colour_by = "donor",
  other_fields = "tissue") + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  guides(fill = FALSE) +
  ylab("logCPM(read counts)") +
  ylim(0, NA) +
  facet_grid(~tissue) +
  theme(axis.text.x = element_blank()) + 
  xlab("")
p3 <-plotExpression(
  sce,
  "XIST",
  x = "donor",
  exprs_values = "UMI_counts",
  colour_by = "donor",
  other_fields = "tissue") + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  guides(fill = FALSE) +
  ylab("UMI counts")  +
  ylim(0, NA) +
  facet_grid(~tissue) +
  theme(axis.text.x = element_blank()) + 
  xlab("")
p4 <- plotExpression(
  sce,
  "XIST",
  x = "donor",
  exprs_values = "logCPM_umis",
  colour_by = "donor",
  other_fields = "tissue") + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  guides(fill = FALSE) +
  ylab("logCPM(UMI counts)") +
  ylim(0, NA) +
  facet_grid(~tissue) +
  theme(axis.text.x = element_blank()) + 
  xlab("")

p1 + p2 + p3 + p4 + 
  plot_layout(guides = "collect", ncol = 2) +
  plot_annotation(title = "XIST")
```

### Using Y chromosome gene expression

Figure \@ref(fig:chr-Y-expression) visualises the proportion of read counts coming from Y chromosome genes.
This can be used to confirm the reported sex of the sample and to detect sample mix-ups.

**TODO** Re-write: Results are clear for `Thymus` but less so for `Blood` (SKW3 has similar to male `Thymus` samples (data not shown)).

Figure \@ref(fig:chr-Y-expression) shows that male samples have higher average proportion of read counts of Y chromosome genes than female samples, as we would expect.

```{r chr-Y-expression, fig.cap = "Proportion of read counts coming from Y chromosome genes by donor and tissue."}
is_Y <- any(rowData(sce)$ENSEMBL.SEQNAME == "Y")
z <- addPerCellQC(
  sce, 
  subsets = list(Y = which(is_Y)),
  use.altexps = "ERCC",
  assay.type = "UMI_counts")

plotColData(
  z,
  "subsets_Y_percent",
  x = "donor",
  other_fields = "tissue",
  colour_by = "donor",
  point_alpha = 1) +
  ylim(0, NA) +
  theme(axis.text.x = element_blank()) + 
  scale_colour_manual(values = donor_colours, name = "donor") +
  xlab("") +
  facet_grid(~tissue) +
  guides(colour = guide_legend(override.aes = list(size = 4, alpha = 1)))
```

# Concluding remarks

```{r}
# Remove some unneeded assays
assay(sce, "logCPM_reads") <- NULL
assay(sce, "logCPM_umis") <- NULL

# Save
saveRDS(
  sce,
  here("data", "SCEs", "C094_Pellicci.mini-bulk.preprocessed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C094_Pellicci.mini-bulk.preprocessed.SCE.rds`](../data/SCEs/C094_Pellicci.mini-bulk.preprocessed.SCE.rds)).
This will be used in downstream analyses, i.e. differential expression analysis.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>

# TODOs

- [ ] How many reads/sample were we aiming for?
- [ ] Why are `Blood.1` - `Blood.3` `P5` whereas `Blood.4` - `Blood.8` `P8`?
- [ ] Sex of donors?
